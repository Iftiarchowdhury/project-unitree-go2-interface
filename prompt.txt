I am developping a unitree go2 web interface to control the go2 robot.
in the current developed project, in frontend and backend configuration, I sent a request to the backend from the fronted and it only prints the request data.
now I have developed two scirpts. one is for sensor data fetch from unitree robot and another one for video streaming. you task is to analyze the whole project,
and modify the scirpts and add them to the backend so that it can connect to the robot and stream its video. I will provide you the code of 
frontend and backend.

the features you need to implement:
	1. In the control interface there is a window for video streaming. when I enter the robot ip , and press connect, it will show a notification that robot is connected.
	then I wanna see the video feed of the robot in this window. I have achived it with the video streming script.
	2. in the stats page , I want to show the stats of the robot. which I have done with the sensor data script.
	3. I also wanna control the robot, when I will press the control buttons and execute commands in the control page, 
	the backend will fetch the request and send it  to the robot to execute.
	you will also develop a script that will send command to the robot. I will provide a codebase where you will 
	find similar scripts.



now you will-
	1. analyze the scripts , frontend codebase and backend codebase.
	then you will analyze the requirements of requested features. and you will complete them one by one.
	2. create a list of files you need to generate or modify to implement the features.
	3. generate and modify required files but u have to mention where to modify which file to modify.
    4. if the file is long  to generate then you will ask if I wanna continue. if I type continue 
    then you will generate the file.
 





script for sensor data fetch from unitree robot:

	# Import the asyncio library to support asynchronous programming, which is required for WebRTC connections
	import asyncio 
	# Import the logging module to control log output levels
	import logging
	# Import sys module for system-related functions like exiting the program
	import sys
	# Import the WebRTC connection classes from the go2_webrtc_driver package
	from go2_webrtc_driver.webrtc_driver import Go2WebRTCConnection, WebRTCConnectionMethod
	# Import the RTC_TOPIC constants that define the communication channels with the robot
	from go2_webrtc_driver.constants import RTC_TOPIC

	# Configure logging to only show fatal errors, reducing console output
	logging.basicConfig(level=logging.FATAL)

	def display_sensor_data(message):
		"""Format and display various sensor data from the robot"""
		
		# Extract the IMU (Inertial Measurement Unit) data for roll, pitch, yaw from the message
		imu_state = message['imu_state']['rpy']
		# Extract the motor state information for all motors
		motor_state = message['motor_state']
		# Extract battery management system data
		bms_state = message['bms_state']
		# Extract foot force sensor data (pressure sensors in the robot's feet)
		foot_force = message['foot_force']
		# Extract the temperature from NTC1 sensor (Negative Temperature Coefficient thermistor)
		temperature_ntc1 = message['temperature_ntc1']
		# Extract the power voltage information
		power_v = message['power_v']

		# Clear the terminal screen by using ANSI escape codes:
		# \033[H moves cursor to top-left corner
		# \033[J clears the screen from cursor position to end
		sys.stdout.write("\033[H\033[J")

		# Print a header for the robot status display with decorative equals signs
		print("\n===== Unitree Go2 Robot Sensor Data =====\n")

		# Print the IMU data section with a compass emoji
		print("ðŸ§­ IMU Data (Roll, Pitch, Yaw):")
		# Format roll with 2 decimal places
		print(f"   Roll:  {imu_state[0]:.2f}")
		# Format pitch with 2 decimal places
		print(f"   Pitch: {imu_state[1]:.2f}")
		# Format yaw with 2 decimal places
		print(f"   Yaw:   {imu_state[2]:.2f}")

		# Print the battery status section with a battery emoji
		print("\nðŸ”‹ Battery Status:")
		# Display state of charge as a percentage
		print(f"   Charge:       {bms_state['soc']}%")
		# Display current in milliamperes
		print(f"   Current:      {bms_state['current']} mA")
		# Display battery cycle count (charge/discharge cycles)
		print(f"   Cycle Count:  {bms_state['cycle']}")
		# Display temperatures from both BQ and MCU thermistors
		print(f"   Temperature:  {bms_state['bq_ntc']}Â°C (BQ), {bms_state['mcu_ntc']}Â°C (MCU)")
		
		# Print motor status section with a gear emoji, limiting to first 4 motors for clarity
		print("\nâš™ï¸ Motor Status (First 4 motors):")
		# Loop through the first 4 motors and print their data
		for i, motor in enumerate(motor_state[:4]):
			# Display position (q), temperature, and connection status for each motor
			print(f"   Motor {i+1}: Position={motor['q']:.4f}, Temperature={motor['temperature']}Â°C, Status={'LOST' if motor['lost'] else 'OK'}")

		# Print foot force sensor data with footprints emoji
		print("\nðŸ‘£ Foot Force Sensors:")
		# Display raw foot force sensor values
		print(f"   {foot_force}")
		
		# Print additional sensor data with thermometer emoji
		print("\nðŸŒ¡ï¸ Additional Sensors:")
		# Display NTC1 temperature in Celsius
		print(f"   NTC1 Temperature: {temperature_ntc1}Â°C")
		# Display power voltage in Volts
		print(f"   Power Voltage:    {power_v}V")
		
		# Print a footer line to visually close the data display
		print("\n=========================================")
		
		# Ensure the output is immediately displayed by flushing stdout
		# This is useful when running in environments where output might be buffered
		sys.stdout.flush()

	async def main():
		try:
			# Print a message indicating the connection attempt is starting
			print("Connecting to the Unitree Go2 robot...")
			
			# Create a connection object for the robot using Local STA Mode
			# This means the robot is on the same local network as your computer
			# Replace the IP with your robot's actual IP address
			conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, ip="192.168.8.181")
			
			# Alternative connection method using serial number instead of IP
			# Uncomment and use this if you prefer to connect by serial number
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, serialNumber="B42D2000XXXXXXXX")
			
			# Establish the WebRTC connection to the robot
			# This is an asynchronous operation, so we use "await"
			await conn.connect()
			
			# Print success message once connected
			print("Connected to robot! Fetching sensor data...")

			# Define a callback function that will be called whenever new sensor data arrives
			def lowstate_callback(message):
				# Extract the data payload from the message wrapper
				current_message = message['data']
				# Call our display function with the extracted data
				display_sensor_data(current_message)

			# Subscribe to the LOW_STATE data channel to receive sensor updates
			# This uses the RTC_TOPIC constant defined in the constants.py file
			# The callback function will be called each time new data arrives
			conn.datachannel.pub_sub.subscribe(RTC_TOPIC['LOW_STATE'], lowstate_callback)
			
			# Print confirmation that subscription was successful
			print("Subscribed to LOW_STATE data channel")
			print("Displaying sensor data. Press Ctrl+C to exit...\n")

			# Keep the program running to continue receiving data updates
			# Sleep for 3600 seconds (1 hour) or until interrupted
			await asyncio.sleep(3600)

		except ValueError as e:
			# Handle value errors specifically (like invalid IP address)
			logging.error(f"An error occurred: {e}")
			print(f"Error: {e}")
		except Exception as e:
			# Handle any other unexpected errors
			print(f"Unexpected error: {e}")

	# Script entry point - this code runs when the script is executed directly
	if __name__ == "__main__":
		try:
			# Run the main async function
			asyncio.run(main())
		except KeyboardInterrupt:
			# Handle the case when user presses Ctrl+C to exit
			print("\nProgram interrupted by user")
			# Exit the program with status code 0 (successful exit)
			sys.exit(0)
		
		
	
script for video streeming:	
	import cv2
	import numpy as np

	# Create an OpenCV window and display a blank image
	height, width = 720, 1280  # Adjust the size as needed
	img = np.zeros((height, width, 3), dtype=np.uint8)
	cv2.imshow('Video', img)
	cv2.waitKey(1)  # Ensure the window is created

	import asyncio
	import logging
	import threading
	import time
	from queue import Queue
	from go2_webrtc_driver.webrtc_driver import Go2WebRTCConnection, WebRTCConnectionMethod
	from aiortc import MediaStreamTrack

	# Enable logging for debugging
	logging.basicConfig(level=logging.FATAL)

	def main():
		frame_queue = Queue()

		# Choose a connection method (uncomment the correct one)
		conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, ip="192.168.8.181")
		# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, serialNumber="B42D2000XXXXXXXX")
		# conn = Go2WebRTCConnection(WebRTCConnectionMethod.Remote, serialNumber="B42D2000XXXXXXXX", username="email@gmail.com", password="pass")
		# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalAP)

		# Async function to receive video frames and put them in the queue
		async def recv_camera_stream(track: MediaStreamTrack):
			while True:
				frame = await track.recv()
				# Convert the frame to a NumPy array
				img = frame.to_ndarray(format="bgr24")
				frame_queue.put(img)

		def run_asyncio_loop(loop):
			asyncio.set_event_loop(loop)
			async def setup():
				try:
					# Connect to the device
					await conn.connect()

					# Switch video channel on and start receiving video frames
					conn.video.switchVideoChannel(True)

					# Add callback to handle received video frames
					conn.video.add_track_callback(recv_camera_stream)
				except Exception as e:
					logging.error(f"Error in WebRTC connection: {e}")

			# Run the setup coroutine and then start the event loop
			loop.run_until_complete(setup())
			loop.run_forever()

		# Create a new event loop for the asyncio code
		loop = asyncio.new_event_loop()

		# Start the asyncio event loop in a separate thread
		asyncio_thread = threading.Thread(target=run_asyncio_loop, args=(loop,))
		asyncio_thread.start()

		try:
			while True:
				if not frame_queue.empty():
					img = frame_queue.get()
					print(f"Shape: {img.shape}, Dimensions: {img.ndim}, Type: {img.dtype}, Size: {img.size}")
					# Display the frame
					cv2.imshow('Video', img)
					if cv2.waitKey(1) & 0xFF == ord('q'):
						break
				else:
					# Sleep briefly to prevent high CPU usage
					time.sleep(0.01)
		finally:
			cv2.destroyAllWindows()
			# Stop the asyncio event loop
			loop.call_soon_threadsafe(loop.stop)
			asyncio_thread.join()

	if __name__ == "__main__":
		main()
		
		
codebase of backend:
    ================================================================
    File Summary
    ================================================================



    File Format:
    ------------
    The content is organized as follows:
    1. This summary section
    2. Repository information
    3. Repository structure
    4. Multiple file entries, each consisting of:
    a. A separator line (================)
    b. The file path (File: path/to/file)
    c. Another separator line
    d. The full contents of the file
    e. A blank line



    ================================================================
    Repository Structure
    ================================================================
    app/__init__.py
    app/api/routes.py
    app/domain/entities/robot.py
    app/domain/interfaces/robot_repository.py
    app/infrastructure/repositories/robot_repository.py
    app/usecases/robot_service.py
    requirements.txt
    run.py

    ================================================================
    Repository Files
    ================================================================

    ================
    File: app/__init__.py
    ================
    # app/__init__.py
    from flask import Flask
    from flask_cors import CORS

    def create_app():
        app = Flask(__name__)

        # Configure CORS
        CORS(app,
            resources={r"/api/*": {
                "origins": ["http://localhost:5173"],
                "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
                "allow_headers": ["Content-Type", "Authorization"],
                "supports_credentials": True,
                "expose_headers": ["Content-Range", "X-Content-Range"],
                "max_age": 120,
                "send_wildcard": False
            }},
            supports_credentials=True,
            allow_headers=["Content-Type", "Authorization"],
            expose_headers=["Content-Range", "X-Content-Range"]
        )

        # Import and register blueprints
        from app.api.routes import api_bp
        app.register_blueprint(api_bp, url_prefix='/api')

        @app.after_request
        def after_request(response):
            response.headers.add('Access-Control-Allow-Credentials', 'true')
            return response

        return app






    # from flask import Flask
    # from flask_cors import CORS
    #
    #
    # def create_app():
    #     app = Flask(__name__)
    #
    #     # Configure CORS properly
    #     CORS(app, resources={
    #         r"/api/*": {
    #             "origins": ["http://localhost:5173"],
    #             "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    #             "allow_headers": ["Content-Type", "Authorization", "Content-Length", "X-Requested-With"],
    #             "expose_headers": ["Content-Range", "X-Content-Range"],
    #             "supports_credentials": True
    #         }
    #     })
    #
    #     # Import and register blueprints
    #     from app.api.routes import api_bp
    #     app.register_blueprint(api_bp, url_prefix='/api')
    #
    #     return app

    ================
    File: app/api/routes.py
    ================
    # app/api/routes.py
    from flask import Blueprint, jsonify, request, make_response
    from flask_cors import cross_origin
    from app.infrastructure.repositories.robot_repository import RobotRepository
    from app.usecases.robot_service import RobotService

    api_bp = Blueprint('api', __name__)
    robot_repository = RobotRepository()
    robot_service = RobotService(robot_repository)

    # Common CORS decorator configuration
    cors_config = {
        "origins": ["http://localhost:5173"],
        "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        "allow_headers": ["Content-Type", "Authorization"],
        "supports_credentials": True,
        "expose_headers": ["Content-Range", "X-Content-Range"]
    }

    @api_bp.route('/robot/connect', methods=['POST', 'OPTIONS'])
    @cross_origin(**cors_config)
    def connect():
        if request.method == 'OPTIONS':
            response = make_response()
            response.headers.add('Access-Control-Allow-Credentials', 'true')
            response.headers.add('Access-Control-Allow-Methods', 'POST')
            response.headers.add('Access-Control-Allow-Headers', 'Content-Type')
            return response

        data = request.get_json()
        ip_address = data.get('ipAddress')

        if not ip_address:
            return jsonify({'error': 'IP address is required'}), 400

        try:
            robot_service.connect(ip_address)
            return jsonify({'message': 'Connected successfully'}), 200
        except Exception as e:
            return jsonify({'error': str(e)}), 500

    @api_bp.route('/robot/terminate', methods=['POST', 'OPTIONS'])
    @cross_origin(**cors_config)
    def terminate():
        if request.method == 'OPTIONS':
            response = make_response()
            response.headers.add('Access-Control-Allow-Credentials', 'true')
            response.headers.add('Access-Control-Allow-Methods', 'POST')
            response.headers.add('Access-Control-Allow-Headers', 'Content-Type')
            return response

        try:
            robot_service.disconnect()
            return jsonify({'message': 'Session terminated successfully'}), 200
        except Exception as e:
            return jsonify({'error': str(e)}), 500

    @api_bp.route('/robot/command', methods=['POST', 'OPTIONS'])
    @cross_origin(**cors_config)
    def send_command():
        if request.method == 'OPTIONS':
            response = make_response()
            response.headers.add('Access-Control-Allow-Credentials', 'true')
            response.headers.add('Access-Control-Allow-Methods', 'POST')
            response.headers.add('Access-Control-Allow-Headers', 'Content-Type')
            return response

        data = request.get_json()
        command = data.get('command')

        if not command:
            return jsonify({'error': 'Command is required'}), 400

        try:
            robot_service.send_command(command)
            return jsonify({'message': f'Command {command} sent successfully'}), 200
        except ConnectionError as e:
            return jsonify({'error': str(e)}), 400
        except Exception as e:
            return jsonify({'error': str(e)}), 500

    @api_bp.route('/robot/status', methods=['GET', 'OPTIONS'])
    @cross_origin(**cors_config)
    def get_status():
        if request.method == 'OPTIONS':
            response = make_response()
            response.headers.add('Access-Control-Allow-Credentials', 'true')
            response.headers.add('Access-Control-Allow-Methods', 'GET')
            response.headers.add('Access-Control-Allow-Headers', 'Content-Type')
            return response

        try:
            state = robot_service.get_state()
            return jsonify({
                'battery': state.battery,
                'temperature': state.temperature,
                'humidity': state.humidity,
                'cpuUsage': state.cpu_usage,
                'powerConsumption': state.power_consumption,
                'speed': state.speed,
                'mode': state.mode,
                'uptime': state.uptime,
                'errors': state.errors
            }), 200
        except ConnectionError as e:
            return jsonify({'error': str(e)}), 400
        except Exception as e:
            return jsonify({'error': str(e)}), 500

    @api_bp.route('/robot/logs', methods=['POST', 'OPTIONS'])
    @cross_origin(**cors_config)
    def log_operation():
        if request.method == 'OPTIONS':
            response = make_response()
            response.headers.add('Access-Control-Allow-Credentials', 'true')
            response.headers.add('Access-Control-Allow-Methods', 'POST')
            response.headers.add('Access-Control-Allow-Headers', 'Content-Type')
            return response

        data = request.get_json()
        operation = data.get('operation')
        timestamp = data.get('timestamp')
        user_id = data.get('userId')

        if not all([operation, timestamp, user_id]):
            return jsonify({'error': 'Missing required fields'}), 400

        try:
            # Here you would typically save the log to your database
            # For now, we'll just print it
            print(f"Log: {operation} by user {user_id} at {timestamp}")
            return jsonify({'message': 'Operation logged successfully'}), 200
        except Exception as e:
            return jsonify({'error': str(e)}), 500

    ================
    File: app/domain/entities/robot.py
    ================
    from dataclasses import dataclass
    from typing import Optional

    @dataclass
    class RobotState:
        battery: float
        temperature: float
        humidity: float
        cpu_usage: float
        power_consumption: float
        speed: float
        mode: str
        uptime: int
        errors: int

    @dataclass
    class RobotCommand:
        command: str
        parameters: Optional[dict] = None

    ================
    File: app/domain/interfaces/robot_repository.py
    ================
    from abc import ABC, abstractmethod
    from app.domain.entities.robot import RobotState, RobotCommand

    class RobotRepositoryInterface(ABC):
        @abstractmethod
        def connect(self, ip_address: str) -> bool:
            pass
        
        @abstractmethod
        def disconnect(self) -> bool:
            pass
        
        @abstractmethod
        def send_command(self, command: RobotCommand) -> bool:
            pass
        
        @abstractmethod
        def get_state(self) -> RobotState:
            pass

    ================
    File: app/infrastructure/repositories/robot_repository.py
    ================
    from app.domain.interfaces.robot_repository import RobotRepositoryInterface
    from app.domain.entities.robot import RobotState, RobotCommand
    import random

    class RobotRepository(RobotRepositoryInterface):
        def __init__(self):
            self.connected = False
            self.ip_address = None
        
        def connect(self, ip_address: str) -> bool:
            # Simulate connection
            print(f"Connecting to robot at {ip_address}")
            self.connected = True
            self.ip_address = ip_address
            return True
        
        def disconnect(self) -> bool:
            # Simulate disconnection
            print(f"Disconnecting from robot at {self.ip_address}")
            self.connected = False
            self.ip_address = None
            return True
        
        def send_command(self, command: RobotCommand) -> bool:
            if not self.connected:
                raise ConnectionError("Not connected to robot")
            # Simulate sending command
            print(f"Sending command {command.command} to robot")
            return True
        
        def get_state(self) -> RobotState:
            if not self.connected:
                raise ConnectionError("Not connected to robot")
            # Simulate getting robot state with random values
            return RobotState(
                battery=random.uniform(20, 100),
                temperature=random.uniform(20, 80),
                humidity=random.uniform(30, 70),
                cpu_usage=random.uniform(10, 90),
                power_consumption=random.uniform(100, 500),
                speed=random.uniform(0, 5),
                mode=random.choice(['Manual', 'Autonomous', 'Hybrid']),
                uptime=random.randint(0, 86400),
                errors=random.randint(0, 5)
            )

    ================
    File: app/usecases/robot_service.py
    ================
    from app.domain.interfaces.robot_repository import RobotRepositoryInterface
    from app.domain.entities.robot import RobotCommand, RobotState

    class RobotService:
        def __init__(self, repository: RobotRepositoryInterface):
            self.repository = repository
        
        def connect(self, ip_address: str) -> bool:
            return self.repository.connect(ip_address)
        
        def disconnect(self) -> bool:
            return self.repository.disconnect()
        
        def send_command(self, command: str, parameters: dict = None) -> bool:
            cmd = RobotCommand(command=command, parameters=parameters)
            return self.repository.send_command(cmd)
        
        def get_state(self) -> RobotState:
            return self.repository.get_state()

    ================
    File: requirements.txt
    ================
    flask==2.3.3
    flask-cors==4.0.0
    python-dotenv==1.0.0

    ================
    File: run.py
    ================
    from flask import Flask
    from app.api.routes import api_bp
    from flask_cors import CORS

    # Remove duplicate app creation
    app = Flask(__name__)

    # Configure CORS properly
    # CORS(app, resources={
    #     r"/api/*": {
    #         "origins": ["http://localhost:5173"],
    #         "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    #         "allow_headers": ["Content-Type", "Authorization", "Content-Length", "X-Requested-With"],
    #         "expose_headers": ["Content-Range", "X-Content-Range"],
    #         "supports_credentials": True
    #     }
    # })

    # Register blueprint
    app.register_blueprint(api_bp, url_prefix='/api')

    if __name__ == '__main__':
        app.run(debug=True, host='0.0.0.0', port=5000)





codebase of fronted:
  ================================================================
  File Summary
  ================================================================



  File Format:
  ------------
  The content is organized as follows:
  1. This summary section
  2. Repository information
  3. Repository structure
  4. Multiple file entries, each consisting of:
    a. A separator line (================)
    b. The file path (File: path/to/file)
    c. Another separator line
    d. The full contents of the file
    e. A blank line



  ================================================================
  Repository Structure
  ================================================================
  .env.example
  .gitignore
  eslint.config.js
  index.html
  package.json
  postcss.config.js
  README.md
  src/App.tsx
  src/components/Auth/AuthContext.tsx
  src/components/Auth/AuthProvider.tsx
  src/components/Auth/index.ts
  src/components/Auth/LoginPage.tsx
  src/components/Auth/RegisterPage.tsx
  src/components/Config/ConfigPage.tsx
  src/components/Control/ControlView.tsx
  src/components/Layout/Footer.tsx
  src/components/Layout/Header.tsx
  src/components/Layout/index.ts
  src/components/Layout/Sidebar.tsx
  src/components/Notifications/NotificationsView.tsx
  src/components/Profile/ProfileView.tsx
  src/components/Stats/StatsView.tsx
  src/components/Users/UserItem.tsx
  src/components/Users/UserList.tsx
  src/config/firebase.config.ts
  src/env.d.ts
  src/index.css
  src/main.tsx
  src/routes.tsx
  src/services/api.ts
  src/services/dummyApi.ts
  src/services/firebase.ts
  src/services/robotService.ts
  src/types/index.ts
  src/types/notifications.ts
  src/vite-env.d.ts
  tailwind.config.js
  tsconfig.app.json
  tsconfig.json
  tsconfig.node.json
  vite.config.ts

  ================================================================
  Repository Files
  ================================================================

  ================
  File: .env.example
  ================
  VITE_FIREBASE_API_KEY=
  VITE_FIREBASE_AUTH_DOMAIN=
  VITE_FIREBASE_PROJECT_ID=
  VITE_FIREBASE_STORAGE_BUCKET=
  VITE_FIREBASE_MESSAGING_SENDER_ID=
  VITE_FIREBASE_APP_ID=
  VITE_FIREBASE_DATABASE_URL=

  ================
  File: .gitignore
  ================
  # Logs
  logs
  *.log
  npm-debug.log*
  yarn-debug.log*
  yarn-error.log*
  pnpm-debug.log*
  lerna-debug.log*

  node_modules
  dist
  dist-ssr
  *.local

  # Environment files
  .env
  .env.local
  .env.development
  .env.production

  # Editor directories and files
  .vscode/*
  !.vscode/extensions.json
  .idea
  .DS_Store
  *.suo
  *.ntvs*
  *.njsproj
  *.sln
  *.sw?

  ================
  File: eslint.config.js
  ================
  import js from '@eslint/js';
  import globals from 'globals';
  import reactHooks from 'eslint-plugin-react-hooks';
  import reactRefresh from 'eslint-plugin-react-refresh';
  import tseslint from 'typescript-eslint';

  export default tseslint.config(
    { ignores: ['dist'] },
    {
      extends: [js.configs.recommended, ...tseslint.configs.recommended],
      files: ['**/*.{ts,tsx}'],
      languageOptions: {
        ecmaVersion: 2020,
        globals: globals.browser,
      },
      plugins: {
        'react-hooks': reactHooks,
        'react-refresh': reactRefresh,
      },
      rules: {
        ...reactHooks.configs.recommended.rules,
        'react-refresh/only-export-components': [
          'warn',
          { allowConstantExport: true },
        ],
      },
    }
  );

  ================
  File: index.html
  ================
  <!doctype html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <link rel="icon" type="image/svg+xml" href="/vite.svg" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Vite + React + TS</title>
    </head>
    <body>
      <div id="root"></div>
      <script type="module" src="/src/main.tsx"></script>
    </body>
  </html>

  ================
  File: package.json
  ================
  {
    "name": "vite-react-typescript-starter",
    "private": true,
    "version": "0.0.0",
    "type": "module",
    "scripts": {
      "start": "vite",
      "dev": "vite",
      "build": "vite build",
      "lint": "eslint .",
      "preview": "vite preview"
    },
    "dependencies": {
      "lucide-react": "^0.344.0",
      "react": "^18.3.1",
      "react-dom": "^18.3.1",
      "axios": "^1.6.7",
      "firebase": "^10.8.0",
      "react-router-dom": "^6.22.1",
      "zustand": "^4.5.1",
      "react-hot-toast": "^2.4.1"
    },
    "devDependencies": {
      "@eslint/js": "^9.9.1",
      "@types/react": "^18.3.5",
      "@types/react-dom": "^18.3.0",
      "@vitejs/plugin-react": "^4.3.1",
      "autoprefixer": "^10.4.18",
      "eslint": "^9.9.1",
      "eslint-plugin-react-hooks": "^5.1.0-rc.0",
      "eslint-plugin-react-refresh": "^0.4.11",
      "globals": "^15.9.0",
      "postcss": "^8.4.35",
      "tailwindcss": "^3.4.1",
      "typescript": "^5.5.3",
      "typescript-eslint": "^8.3.0",
      "vite": "^5.4.2"
    }
  }

  ================
  File: postcss.config.js
  ================
  export default {
    plugins: {
      tailwindcss: {},
      autoprefixer: {},
    },
  };

  ================
  File: README.md
  ================
  # project-unitree
  This is project for unitree

  ================
  File: src/App.tsx
  ================
  import { Outlet, useLocation } from 'react-router-dom';
  import { Toaster } from 'react-hot-toast';
  import { Header, Sidebar, Footer } from './components/Layout';
  import { AuthProvider } from './components/Auth/AuthProvider';

  function App() {
    const location = useLocation();
    const isAuthPage = ['/login', '/register'].includes(location.pathname);

    return (
      <AuthProvider>
        <div className="min-h-screen bg-gray-900 text-white">
          {!isAuthPage && <Header />}
          <div className="flex">
            {!isAuthPage && <Sidebar />}
            <main className={`${isAuthPage ? 'w-full' : 'flex-1'}`}>
              <Outlet />
            </main>
          </div>
          {!isAuthPage && <Footer />}
        </div>
        <Toaster
          position="top-right"
          toastOptions={{
            className: 'bg-gray-800 text-white',
            duration: 3000,
            style: {
              background: '#1f2937',
              color: '#fff',
            },
          }}
        />
      </AuthProvider>
    );
  }

  export default App;

  ================
  File: src/components/Auth/AuthContext.tsx
  ================
  import { createContext, useContext } from 'react';
  import type { User } from '../../types';

  interface AuthContextType {
    user: User | null;
    loading: boolean;
    isAdmin: boolean;
    login: (email: string, password: string) => Promise<void>;
    logout: () => Promise<void>;
    register: (email: string, password: string, displayName: string) => Promise<void>;
  }

  export const AuthContext = createContext<AuthContextType>({
    user: null,
    loading: true,
    isAdmin: false,
    login: async () => {},
    logout: async () => {},
    register: async () => {},
  });

  export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
      throw new Error('useAuth must be used within an AuthProvider');
    }
    return context;
  };

  ================
  File: src/components/Auth/AuthProvider.tsx
  ================
  import { useState, useEffect } from 'react';
  import { AuthContext } from './AuthContext';
  import { auth, loginUser, logoutUser, registerUser, getUserProfile } from '../../services/firebase';
  import { onAuthStateChanged } from 'firebase/auth';
  import type { User } from '../../types';
  import { toast } from 'react-hot-toast';

  interface AuthProviderProps {
    children: React.ReactNode;
  }

  export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
    const [user, setUser] = useState<User | null>(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
      const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
        if (firebaseUser) {
          try {
            const userProfile = await getUserProfile(firebaseUser.uid);
            if (userProfile) {
              setUser(userProfile);
            }
          } catch (error) {
            console.error('Error fetching user profile:', error);
            toast.error('Error loading user profile');
          }
        } else {
          setUser(null);
        }
        setLoading(false);
      });

      return () => unsubscribe();
    }, []);

    const login = async (email: string, password: string) => {
      try {
        const userCredential = await loginUser(email, password);
        const userProfile = await getUserProfile(userCredential.user.uid);
        if (userProfile) {
          setUser(userProfile);
          toast.success('Successfully logged in');
        }
      } catch (error) {
        console.error('Login error:', error);
        toast.error('Failed to login');
        throw error;
      }
    };

    const logout = async () => {
      try {
        await logoutUser();
        setUser(null);
        toast.success('Successfully logged out');
      } catch (error) {
        console.error('Logout error:', error);
        toast.error('Failed to logout');
        throw error;
      }
    };

    const register = async (email: string, password: string, displayName: string) => {
      try {
        const userCredential = await registerUser(email, password, displayName);
        const userProfile = await getUserProfile(userCredential.user.uid);
        if (userProfile) {
          setUser(userProfile);
          toast.success('Successfully registered');
        }
      } catch (error) {
        console.error('Registration error:', error);
        toast.error('Failed to register');
        throw error;
      }
    };

    return (
      <AuthContext.Provider
        value={{
          user,
          loading,
          isAdmin: user?.role === 'admin',
          login,
          logout,
          register,
        }}
      >
        {children}
      </AuthContext.Provider>
    );
  };

  ================
  File: src/components/Auth/index.ts
  ================
  export { AuthProvider } from './AuthProvider';
  export { useAuth } from './AuthContext';
  export { LoginPage } from './LoginPage';
  export { RegisterPage } from './RegisterPage';

  ================
  File: src/components/Auth/LoginPage.tsx
  ================
  import { useState } from 'react';
  import { useAuth } from './AuthContext';
  import { Link, useNavigate } from 'react-router-dom';
  import { Mail, Lock, LogIn } from 'lucide-react';

  export const LoginPage = () => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [loading, setLoading] = useState(false);
    const { login } = useAuth();
    const navigate = useNavigate();

    const handleSubmit = async (e: React.FormEvent) => {
      e.preventDefault();
      setLoading(true);
      
      try {
        await login(email, password);
        navigate('/control');
      } catch (error) {
        console.error('Login error:', error);
      } finally {
        setLoading(false);
      }
    };

    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-900 py-12 px-4 sm:px-6 lg:px-8">
        <div className="max-w-md w-full space-y-8">
          <div>
            <div className="flex justify-center mb-4">
              <div className="bg-blue-500 p-4 rounded-full">
                <LogIn className="w-8 h-8" />
              </div>
            </div>
            <h2 className="mt-6 text-center text-3xl font-extrabold text-white">
              Sign in to your account
            </h2>
            <p className="mt-2 text-center text-sm text-gray-400">
              Control your robot from anywhere, anytime
            </p>
          </div>
          <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
            <div className="space-y-4">
              <div>
                <label htmlFor="email-address" className="sr-only">
                  Email address
                </label>
                <div className="relative">
                  <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <Mail className="h-5 w-5 text-gray-400" />
                  </div>
                  <input
                    id="email-address"
                    name="email"
                    type="email"
                    autoComplete="email"
                    required
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    className="appearance-none relative block w-full px-3 py-3 pl-10 border border-gray-700 placeholder-gray-400 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 sm:text-sm bg-gray-800 transition-colors"
                    placeholder="Email address"
                  />
                </div>
              </div>
              <div>
                <label htmlFor="password" className="sr-only">
                  Password
                </label>
                <div className="relative">
                  <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <Lock className="h-5 w-5 text-gray-400" />
                  </div>
                  <input
                    id="password"
                    name="password"
                    type="password"
                    autoComplete="current-password"
                    required
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    className="appearance-none relative block w-full px-3 py-3 pl-10 border border-gray-700 placeholder-gray-400 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 sm:text-sm bg-gray-800 transition-colors"
                    placeholder="Password"
                  />
                </div>
              </div>
            </div>

            <div>
              <button
                type="submit"
                disabled={loading}
                className="group relative w-full flex justify-center py-3 px-4 border border-transparent text-sm font-medium rounded-lg text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
              >
                <span className="absolute left-0 inset-y-0 flex items-center pl-3">
                  <LogIn className="h-5 w-5 text-blue-500 group-hover:text-blue-400" />
                </span>
                {loading ? 'Signing in...' : 'Sign in'}
              </button>
            </div>

            <div className="flex flex-col sm:flex-row items-center justify-between gap-4">
              <div className="text-sm">
                <Link
                  to="/forgot-password"
                  className="font-medium text-blue-500 hover:text-blue-400 transition-colors"
                >
                  Forgot your password?
                </Link>
              </div>
              <div className="text-sm">
                <Link
                  to="/register"
                  className="font-medium text-blue-500 hover:text-blue-400 transition-colors"
                >
                  Don't have an account? Sign up
                </Link>
              </div>
            </div>
          </form>
        </div>
      </div>
    );
  };

  ================
  File: src/components/Auth/RegisterPage.tsx
  ================
  import { useState } from 'react';
  import { useAuth } from './AuthContext';
  import { Link, useNavigate } from 'react-router-dom';
  import { Mail, Lock, User, UserPlus } from 'lucide-react';

  export const RegisterPage = () => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [displayName, setDisplayName] = useState('');
    const [loading, setLoading] = useState(false);
    const { register } = useAuth();
    const navigate = useNavigate();

    const handleSubmit = async (e: React.FormEvent) => {
      e.preventDefault();
      setLoading(true);
      
      try {
        await register(email, password, displayName);
        navigate('/control');
      } catch (error) {
        console.error('Registration error:', error);
      } finally {
        setLoading(false);
      }
    };

    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-900 py-12 px-4 sm:px-6 lg:px-8">
        <div className="max-w-md w-full space-y-8">
          <div>
            <div className="flex justify-center mb-4">
              <div className="bg-blue-500 p-4 rounded-full">
                <UserPlus className="w-8 h-8" />
              </div>
            </div>
            <h2 className="mt-6 text-center text-3xl font-extrabold text-white">
              Create your account
            </h2>
            <p className="mt-2 text-center text-sm text-gray-400">
              Join us to start controlling your robot
            </p>
          </div>
          <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
            <div className="space-y-4">
              <div>
                <label htmlFor="display-name" className="sr-only">
                  Display Name
                </label>
                <div className="relative">
                  <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <User className="h-5 w-5 text-gray-400" />
                  </div>
                  <input
                    id="display-name"
                    name="displayName"
                    type="text"
                    required
                    value={displayName}
                    onChange={(e) => setDisplayName(e.target.value)}
                    className="appearance-none relative block w-full px-3 py-3 pl-10 border border-gray-700 placeholder-gray-400 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 sm:text-sm bg-gray-800 transition-colors"
                    placeholder="Display Name"
                  />
                </div>
              </div>
              <div>
                <label htmlFor="email-address" className="sr-only">
                  Email address
                </label>
                <div className="relative">
                  <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <Mail className="h-5 w-5 text-gray-400" />
                  </div>
                  <input
                    id="email-address"
                    name="email"
                    type="email"
                    autoComplete="email"
                    required
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    className="appearance-none relative block w-full px-3 py-3 pl-10 border border-gray-700 placeholder-gray-400 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 sm:text-sm bg-gray-800 transition-colors"
                    placeholder="Email address"
                  />
                </div>
              </div>
              <div>
                <label htmlFor="password" className="sr-only">
                  Password
                </label>
                <div className="relative">
                  <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <Lock className="h-5 w-5 text-gray-400" />
                  </div>
                  <input
                    id="password"
                    name="password"
                    type="password"
                    autoComplete="new-password"
                    required
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    className="appearance-none relative block w-full px-3 py-3 pl-10 border border-gray-700 placeholder-gray-400 text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 sm:text-sm bg-gray-800 transition-colors"
                    placeholder="Password"
                  />
                </div>
              </div>
            </div>

            <div>
              <button
                type="submit"
                disabled={loading}
                className="group relative w-full flex justify-center py-3 px-4 border border-transparent text-sm font-medium rounded-lg text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
              >
                <span className="absolute left-0 inset-y-0 flex items-center pl-3">
                  <UserPlus className="h-5 w-5 text-blue-500 group-hover:text-blue-400" />
                </span>
                {loading ? 'Creating account...' : 'Create account'}
              </button>
            </div>

            <div className="text-center mt-4">
              <div className="text-sm">
                <Link
                  to="/login"
                  className="font-medium text-blue-500 hover:text-blue-400 transition-colors"
                >
                  Already have an account? Sign in
                </Link>
              </div>
            </div>
          </form>
        </div>
      </div>
    );
  };

  ================
  File: src/components/Config/ConfigPage.tsx
  ================
  import { useState } from 'react';
  import { Settings, Save, RotateCcw } from 'lucide-react';
  import { toast } from 'react-hot-toast';

  interface ConfigSection {
    title: string;
    description: string;
    fields: {
      key: string;
      label: string;
      type: 'text' | 'number' | 'switch' | 'select';
      options?: string[];
      value: any;
    }[];
  }

  export const ConfigPage = () => {
    const [configSections, setConfigSections] = useState<ConfigSection[]>([
      {
        title: 'Robot Settings',
        description: 'Configure basic robot parameters',
        fields: [
          {
            key: 'maxSpeed',
            label: 'Maximum Speed (m/s)',
            type: 'number',
            value: 2.5
          },
          {
            key: 'operationMode',
            label: 'Operation Mode',
            type: 'select',
            options: ['Manual', 'Autonomous', 'Hybrid'],
            value: 'Manual'
          }
        ]
      },
      {
        title: 'Safety Settings',
        description: 'Configure safety parameters',
        fields: [
          {
            key: 'emergencyStop',
            label: 'Emergency Stop Enabled',
            type: 'switch',
            value: true
          },
          {
            key: 'obstacleDistance',
            label: 'Minimum Obstacle Distance (m)',
            type: 'number',
            value: 0.5
          }
        ]
      }
    ]);

    const handleFieldChange = (sectionIndex: number, fieldIndex: number, value: any) => {
      const newSections = [...configSections];
      newSections[sectionIndex].fields[fieldIndex].value = value;
      setConfigSections(newSections);
    };

    const handleSave = async () => {
      try {
        // Here you would typically save to your backend
        toast.success('Configuration saved successfully');
      } catch (error) {
        console.error('Error saving configuration:', error);
        toast.error('Failed to save configuration');
      }
    };

    const handleReset = () => {
      // Here you would typically reset to default values
      toast.success('Configuration reset to defaults');
    };

    return (
      <div className="container mx-auto px-6 py-8">
        <div className="flex justify-between items-center mb-8">
          <div className="flex items-center gap-3">
            <Settings className="w-6 h-6 text-blue-500" />
            <h1 className="text-2xl font-bold">System Configuration</h1>
          </div>
          <div className="flex gap-4">
            <button
              onClick={handleReset}
              className="flex items-center gap-2 px-4 py-2 bg-gray-700 rounded-lg hover:bg-gray-600 transition"
            >
              <RotateCcw className="w-5 h-5" />
              <span>Reset to Defaults</span>
            </button>
            <button
              onClick={handleSave}
              className="flex items-center gap-2 px-4 py-2 bg-blue-600 rounded-lg hover:bg-blue-700 transition"
            >
              <Save className="w-5 h-5" />
              <span>Save Changes</span>
            </button>
          </div>
        </div>

        <div className="space-y-6">
          {configSections.map((section, sectionIndex) => (
            <div key={section.title} className="bg-gray-800 rounded-lg p-6">
              <h2 className="text-xl font-semibold mb-2">{section.title}</h2>
              <p className="text-gray-400 mb-6">{section.description}</p>
              
              <div className="space-y-4">
                {section.fields.map((field, fieldIndex) => (
                  <div key={field.key} className="flex items-center justify-between">
                    <label className="flex-1">{field.label}</label>
                    <div className="w-64">
                      {field.type === 'switch' ? (
                        <button
                          onClick={() => handleFieldChange(sectionIndex, fieldIndex, !field.value)}
                          className={`w-12 h-6 rounded-full transition-colors ${
                            field.value ? 'bg-blue-600' : 'bg-gray-600'
                          }`}
                        >
                          <div
                            className={`w-4 h-4 rounded-full bg-white transition-transform ${
                              field.value ? 'translate-x-7' : 'translate-x-1'
                            }`}
                          />
                        </button>
                      ) : field.type === 'select' ? (
                        <select
                          value={field.value}
                          onChange={(e) => handleFieldChange(sectionIndex, fieldIndex, e.target.value)}
                          className="w-full bg-gray-700 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        >
                          {field.options?.map(option => (
                            <option key={option} value={option}>{option}</option>
                          ))}
                        </select>
                      ) : (
                        <input
                          type={field.type}
                          value={field.value}
                          onChange={(e) => handleFieldChange(
                            sectionIndex,
                            fieldIndex,
                            field.type === 'number' ? parseFloat(e.target.value) : e.target.value
                          )}
                          className="w-full bg-gray-700 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        />
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          ))}
        </div>
      </div>
    );
  };

  ================
  File: src/components/Control/ControlView.tsx
  ================
  import { useState, useEffect } from 'react';
  import { robotService } from '../../services/robotService';
  import type { RobotStats } from '../../types';
  import { ChevronUp, ChevronDown, ChevronLeft, ChevronRight, Square } from 'lucide-react';
  import { toast } from 'react-hot-toast';

  export const ControlView = () => {
    const [stats, setStats] = useState<RobotStats | null>(null);
    const [ipAddress, setIpAddress] = useState('');
    const [isConnected, setIsConnected] = useState(false);
    const [selectedCommand, setSelectedCommand] = useState('');

    const commands = [
      'standup',
      'sitdown',
      'left',
      'right',
      'forward',
      'backward'
    ];

    const validateIpAddress = (ip: string) => {
      const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/;
      if (!ipRegex.test(ip)) return false;
      const parts = ip.split('.');
      return parts.every(part => {
        const num = parseInt(part);
        return num >= 0 && num <= 255;
      });
    };

    const handleConnect = async () => {
      if (!validateIpAddress(ipAddress)) {
        toast.error('Invalid IP address format');
        return;
      }

      try {
        await robotService.connect(ipAddress);
        setIsConnected(true);
        toast.success('Successfully connected to robot');
      } catch (error) {
        console.error('Connection error:', error);
        toast.error('Failed to connect to robot');
      }
    };

    const handleCommand = async (command: string) => {
      if (!isConnected) {
        toast.error('Please connect to robot first');
        return;
      }

      try {
        await robotService.sendCommand(command);
        toast.success(`Command ${command} sent successfully`);
      } catch (error) {
        console.error('Error sending command:', error);
        toast.error('Failed to send command');
      }
    };

    const handleExecuteCommand = async () => {
      if (!selectedCommand) {
        toast.error('Please select a command');
        return;
      }
      await handleCommand(selectedCommand);
    };

    const handleTerminate = async () => {
      try {
        await robotService.terminateSession();
        setIsConnected(false);
        toast.success('Session terminated successfully');
      } catch (error) {
        console.error('Error terminating session:', error);
        toast.error('Failed to terminate session');
      }
    };

    return (
      <div className="container mx-auto px-6 py-8">
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
          {/* Video Feed */}
          <div className="lg:col-span-2">
            <div className="bg-black rounded-lg overflow-hidden aspect-video">
              <video
                className="w-full h-full object-cover"
                autoPlay
                playsInline
                muted
                loop
                poster="https://www.docs.quadruped.de/projects/go2/html/_images/Go2_Walking.gif"
              >
                <source src="/video-feed-url" type="video/mp4" />
                Your browser does not support video playback.
              </video>
            </div>
          </div>

          {/* Controls */}
          <div className="space-y-6">
            {/* Connection Panel */}
            <div className="bg-gray-800 rounded-lg p-6">
              <h2 className="text-xl font-semibold mb-4">Connection</h2>
              <div className="space-y-4">
                <div>
                  <label htmlFor="ip-address" className="block text-sm font-medium mb-2">
                    Robot IP Address
                  </label>
                  <div className="flex gap-2">
                    <input
                      id="ip-address"
                      type="text"
                      value={ipAddress}
                      onChange={(e) => setIpAddress(e.target.value)}
                      placeholder="192.168.1.100"
                      className="flex-1 bg-gray-700 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                    />
                    <button
                      onClick={handleConnect}
                      disabled={isConnected}
                      className="px-4 py-2 bg-blue-600 rounded-lg hover:bg-blue-700 transition disabled:opacity-50"
                    >
                      {isConnected ? 'Connected' : 'Connect'}
                    </button>
                  </div>
                </div>
              </div>
            </div>

            {/* Control Pad */}
            <div className="bg-gray-800 rounded-lg p-6">
              <h2 className="text-xl font-semibold mb-4">Controls</h2>
              <div className="space-y-4 max-w-[240px] mx-auto">
                {/* First row - Up arrow */}
                <div className="flex justify-center">
                  <button
                    onClick={() => handleCommand('forward')}
                    className="w-16 h-16 bg-gray-700 rounded-lg flex items-center justify-center hover:bg-gray-600 active:bg-gray-500 transition"
                  >
                    <ChevronUp className="w-8 h-8" />
                  </button>
                </div>

                {/* Second row - Left, Stop, Right */}
                <div className="flex justify-center gap-4">
                  <button
                    onClick={() => handleCommand('left')}
                    className="w-16 h-16 bg-gray-700 rounded-lg flex items-center justify-center hover:bg-gray-600 active:bg-gray-500 transition"
                  >
                    <ChevronLeft className="w-8 h-8" />
                  </button>
                  <button
                    onClick={() => handleCommand('stop')}
                    className="w-16 h-16 bg-red-700 rounded-lg flex items-center justify-center hover:bg-red-600 active:bg-red-500 transition"
                  >
                    <Square className="w-8 h-8" />
                  </button>
                  <button
                    onClick={() => handleCommand('right')}
                    className="w-16 h-16 bg-gray-700 rounded-lg flex items-center justify-center hover:bg-gray-600 active:bg-gray-500 transition"
                  >
                    <ChevronRight className="w-8 h-8" />
                  </button>
                </div>

                {/* Third row - Down arrow */}
                <div className="flex justify-center">
                  <button
                    onClick={() => handleCommand('backward')}
                    className="w-16 h-16 bg-gray-700 rounded-lg flex items-center justify-center hover:bg-gray-600 active:bg-gray-500 transition"
                  >
                    <ChevronDown className="w-8 h-8" />
                  </button>
                </div>
              </div>
            </div>

            {/* Command Selection */}
            <div className="bg-gray-800 rounded-lg p-6">
              <h2 className="text-xl font-semibold mb-4">Commands</h2>
              <div className="space-y-4">
                <select
                  value={selectedCommand}
                  onChange={(e) => setSelectedCommand(e.target.value)}
                  className="w-full bg-gray-700 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                >
                  <option value="">Select Command</option>
                  {commands.map((cmd) => (
                    <option key={cmd} value={cmd}>
                      {cmd.charAt(0).toUpperCase() + cmd.slice(1)}
                    </option>
                  ))}
                </select>
                <button
                  onClick={handleExecuteCommand}
                  className="w-full px-4 py-2 bg-blue-600 rounded-lg hover:bg-blue-700 transition"
                >
                  Execute
                </button>
              </div>
            </div>

            {/* Terminate Session */}
            <button
              onClick={handleTerminate}
              className="w-full px-4 py-2 bg-red-600 rounded-lg hover:bg-red-700 transition"
            >
              Terminate Session
            </button>
          </div>
        </div>
      </div>
    );
  };

  ================
  File: src/components/Layout/Footer.tsx
  ================
  export const Footer = () => {
    return (
      <footer className="bg-gray-800">
        <div className="container mx-auto px-6 py-4">
          <div className="flex flex-col md:flex-row justify-between items-center">
            <div className="text-gray-400 text-sm">
              Â© 2024 RoboControl X1. All rights reserved.
            </div>
            <div className="flex gap-4 mt-4 md:mt-0">
              <a
                href="#"
                className="text-gray-400 hover:text-white transition"
              >
                Privacy Policy
              </a>
              <a
                href="#"
                className="text-gray-400 hover:text-white transition"
              >
                Terms of Service
              </a>
              <a
                href="#"
                className="text-gray-400 hover:text-white transition"
              >
                Contact
              </a>
            </div>
          </div>
        </div>
      </footer>
    );
  };

  ================
  File: src/components/Layout/Header.tsx
  ================
  import { useAuth } from '../Auth/AuthContext';
  import { Link } from 'react-router-dom';
  import { LogOut, User } from 'lucide-react';

  export const Header = () => {
    const { user, logout } = useAuth();

    return (
      <header className="bg-gray-800 px-6 py-4">
        <div className="container mx-auto flex justify-between items-center">
          <div className="flex items-center gap-8">
            <Link to="/" className="text-2xl font-bold">
              Go 2 Control Panel
            </Link>
          </div>

          {user && (
            <div className="flex items-center gap-4">
              <Link
                to="/profile"
                className="flex items-center gap-2 px-4 py-2 rounded-lg hover:bg-gray-700 transition"
              >
                <User className="w-5 h-5" />
                <span>{user.displayName}</span>
              </Link>
              <button
                onClick={() => logout()}
                className="p-2 hover:bg-gray-700 rounded-lg transition"
              >
                <LogOut className="w-5 h-5" />
              </button>
            </div>
          )}
        </div>
      </header>
    );
  };

  ================
  File: src/components/Layout/index.ts
  ================
  export { Header } from './Header';
  export { Sidebar } from './Sidebar';
  export { Footer } from './Footer';

  ================
  File: src/components/Layout/Sidebar.tsx
  ================
  import { useAuth } from '../Auth/AuthContext';
  import { Link, useLocation } from 'react-router-dom';
  import {
    Gauge,
    Users,
    Settings,
    BarChart2,
    Gamepad2,
    User,
    Bell,
  } from 'lucide-react';

  export const Sidebar = () => {
    const { isAdmin } = useAuth();
    const location = useLocation();

    const isActive = (path: string) => location.pathname === path;

    const menuItems = [
      { path: '/control', icon: Gamepad2, label: 'Control', showAlways: true },
      { path: '/stats', icon: BarChart2, label: 'Stats', showAlways: true },
      { path: '/profile', icon: User, label: 'Profile', showAlways: true },
      { path: '/notifications', icon: Bell, label: 'Notifications', showAlways: true },
      { path: '/users', icon: Users, label: 'Users', adminOnly: true },
      { path: '/config', icon: Settings, label: 'Configuration', adminOnly: true },
    ];

    return (
      <aside className="bg-gray-800 w-64 min-h-screen p-4">
        <nav className="space-y-2">
          {menuItems.map((item) => {
            if (item.adminOnly && !isAdmin) return null;
            if (!item.showAlways && !isAdmin) return null;

            const Icon = item.icon;
            return (
              <Link
                key={item.path}
                to={item.path}
                className={`flex items-center gap-3 px-4 py-3 rounded-lg transition ${
                  isActive(item.path)
                    ? 'bg-gray-700 text-white'
                    : 'text-gray-300 hover:bg-gray-700 hover:text-white'
                }`}
              >
                <Icon className="w-5 h-5" />
                <span>{item.label}</span>
              </Link>
            );
          })}
        </nav>
      </aside>
    );
  };

  ================
  File: src/components/Notifications/NotificationsView.tsx
  ================
  import { useState, useEffect } from 'react';
  import { dummyApi } from '../../services/dummyApi';
  import type { Notification } from '../../types/notifications';
  import { 
    Bell,
    CheckCircle,
    AlertTriangle,
    Info,
    AlertOctagon,
    Trash2,
    Check,
    MailOpen
  } from 'lucide-react';
  import { toast } from 'react-hot-toast';

  export const NotificationsView = () => {
    const [notifications, setNotifications] = useState<Notification[]>([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
      loadNotifications();
    }, []);

    const loadNotifications = async () => {
      try {
        const data = await dummyApi.getNotifications();
        setNotifications(data);
      } catch (error) {
        console.error('Error loading notifications:', error);
        toast.error('Failed to load notifications');
      } finally {
        setLoading(false);
      }
    };

    const handleMarkAsRead = async (id: string) => {
      try {
        await dummyApi.markAsRead(id);
        setNotifications(notifications.map(notification =>
          notification.id === id ? { ...notification, read: true } : notification
        ));
      } catch (error) {
        console.error('Error marking notification as read:', error);
        toast.error('Failed to mark notification as read');
      }
    };

    const handleMarkAllAsRead = async () => {
      try {
        await dummyApi.markAllAsRead();
        setNotifications(notifications.map(notification => ({ ...notification, read: true })));
        toast.success('All notifications marked as read');
      } catch (error) {
        console.error('Error marking all notifications as read:', error);
        toast.error('Failed to mark all notifications as read');
      }
    };

    const handleDelete = async (id: string) => {
      try {
        await dummyApi.deleteNotification(id);
        setNotifications(notifications.filter(notification => notification.id !== id));
        toast.success('Notification deleted');
      } catch (error) {
        console.error('Error deleting notification:', error);
        toast.error('Failed to delete notification');
      }
    };

    const getIcon = (type: Notification['type']) => {
      switch (type) {
        case 'success':
          return <CheckCircle className="w-5 h-5 text-green-400" />;
        case 'warning':
          return <AlertTriangle className="w-5 h-5 text-yellow-400" />;
        case 'error':
          return <AlertOctagon className="w-5 h-5 text-red-400" />;
        default:
          return <Info className="w-5 h-5 text-blue-400" />;
      }
    };

    if (loading) {
      return (
        <div className="flex justify-center items-center h-64">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
        </div>
      );
    }

    return (
      <div className="container mx-auto px-6 py-8">
        <div className="max-w-4xl mx-auto">
          <div className="flex justify-between items-center mb-6">
            <div className="flex items-center gap-3">
              <Bell className="w-6 h-6 text-blue-500" />
              <h1 className="text-2xl font-bold">Notifications</h1>
            </div>
            {notifications.some(n => !n.read) && (
              <button
                onClick={handleMarkAllAsRead}
                className="flex items-center gap-2 px-4 py-2 bg-gray-700 rounded-lg hover:bg-gray-600 transition"
              >
                <Check className="w-4 h-4" />
                <span>Mark all as read</span>
              </button>
            )}
          </div>

          <div className="space-y-4">
            {notifications.length === 0 ? (
              <div className="text-center py-8 text-gray-400">
                No notifications
              </div>
            ) : (
              notifications.map(notification => (
                <div
                  key={notification.id}
                  className={`bg-gray-800 rounded-lg p-4 ${
                    !notification.read ? 'border-l-4 border-blue-500' : ''
                  }`}
                >
                  <div className="flex items-start justify-between">
                    <div className="flex items-start gap-3">
                      {getIcon(notification.type)}
                      <div>
                        <h3 className="font-semibold">{notification.title}</h3>
                        <p className="text-gray-400 mt-1">{notification.message}</p>
                        <p className="text-sm text-gray-500 mt-2">
                          {new Date(notification.timestamp).toLocaleString()}
                        </p>
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      {!notification.read && (
                        <button
                          onClick={() => handleMarkAsRead(notification.id)}
                          className="p-2 hover:bg-gray-700 rounded-lg transition"
                          title="Mark as read"
                        >
                          <MailOpen className="w-4 h-4" />
                        </button>
                      )}
                      <button
                        onClick={() => handleDelete(notification.id)}
                        className="p-2 hover:bg-gray-700 rounded-lg transition text-red-400"
                        title="Delete"
                      >
                        <Trash2 className="w-4 h-4" />
                      </button>
                    </div>
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      </div>
    );
  };

  ================
  File: src/components/Profile/ProfileView.tsx
  ================
  import { useState, useEffect } from 'react';
  import { useAuth } from '../Auth/AuthContext';
  import { getUserPreferences, updateUserPreferences } from '../../services/firebase';
  import type { UserPreferences } from '../../types';
  import { toast } from 'react-hot-toast';
  import {
    User,
    Mail,
    Calendar,
    Shield,
    Save,
    Moon,
    Bell,
    Sliders,
    Gauge,
    AlertTriangle
  } from 'lucide-react';

  export const ProfileView = () => {
    const { user } = useAuth();
    const [preferences, setPreferences] = useState<UserPreferences | null>(null);
    const [loading, setLoading] = useState(true);
    const [saving, setSaving] = useState(false);

    useEffect(() => {
      loadPreferences();
    }, []);

    const loadPreferences = async () => {
      if (!user) return;
      
      try {
        const prefs = await getUserPreferences(user.id);
        setPreferences(prefs || {
          userId: user.id,
          theme: 'dark',
          notifications: true,
          controlSettings: {
            sensitivity: 1,
            maxSpeed: 2.5,
            safetyLimits: true,
          },
          dashboardLayout: ['stats', 'controls', 'camera']
        });
      } catch (error) {
        console.error('Error loading preferences:', error);
        toast.error('Failed to load preferences');
      } finally {
        setLoading(false);
      }
    };

    const handlePreferenceChange = (
      key: keyof UserPreferences,
      value: any
    ) => {
      if (!preferences) return;
      
      setPreferences({
        ...preferences,
        [key]: value
      });
    };

    const handleControlSettingChange = (
      key: keyof UserPreferences['controlSettings'],
      value: any
    ) => {
      if (!preferences) return;
      
      setPreferences({
        ...preferences,
        controlSettings: {
          ...preferences.controlSettings,
          [key]: value
        }
      });
    };

    const handleSave = async () => {
      if (!user || !preferences) return;
      
      setSaving(true);
      try {
        await updateUserPreferences(user.id, preferences);
        toast.success('Preferences saved successfully');
      } catch (error) {
        console.error('Error saving preferences:', error);
        toast.error('Failed to save preferences');
      } finally {
        setSaving(false);
      }
    };

    if (loading || !user) {
      return (
        <div className="flex justify-center items-center h-64">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
        </div>
      );
    }

    return (
      <div className="container mx-auto px-6 py-8">
        <div className="max-w-4xl mx-auto space-y-8">
          {/* Profile Info */}
          <div className="bg-gray-800 rounded-lg p-6">
            <h2 className="text-xl font-semibold mb-6">Profile Information</h2>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="flex items-center gap-3">
                <User className="w-5 h-5 text-gray-400" />
                <div>
                  <div className="text-sm text-gray-400">Display Name</div>
                  <div>{user.displayName}</div>
                </div>
              </div>
              <div className="flex items-center gap-3">
                <Mail className="w-5 h-5 text-gray-400" />
                <div>
                  <div className="text-sm text-gray-400">Email</div>
                  <div>{user.email}</div>
                </div>
              </div>
              <div className="flex items-center gap-3">
                <Calendar className="w-5 h-5 text-gray-400" />
                <div>
                  <div className="text-sm text-gray-400">Joined</div>
                  <div>{new Date(user.createdAt).toLocaleDateString()}</div>
                </div>
              </div>
              <div className="flex items-center gap-3">
                <Shield className="w-5 h-5 text-gray-400" />
                <div>
                  <div className="text-sm text-gray-400">Role</div>
                  <div className="capitalize">{user.role}</div>
                </div>
              </div>
            </div>
          </div>

          {/* Preferences */}
          {preferences && (
            <div className="bg-gray-800 rounded-lg p-6">
              <div className="flex justify-between items-center mb-6">
                <h2 className="text-xl font-semibold">Preferences</h2>
                <button
                  onClick={handleSave}
                  disabled={saving}
                  className="flex items-center gap-2 px-4 py-2 bg-blue-600 rounded-lg hover:bg-blue-700 transition disabled:opacity-50"
                >
                  <Save className="w-4 h-4" />
                  <span>{saving ? 'Saving...' : 'Save Changes'}</span>
                </button>
              </div>

              <div className="space-y-6">
                {/* General Settings */}
                <div>
                  <h3 className="text-lg font-medium mb-4">General Settings</h3>
                  <div className="space-y-4">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-2">
                        <Moon className="w-5 h-5 text-gray-400" />
                        <span>Dark Theme</span>
                      </div>
                      <button
                        onClick={() => handlePreferenceChange('theme', preferences.theme === 'dark' ? 'light' : 'dark')}
                        className={`w-12 h-6 rounded-full transition-colors ${
                          preferences.theme === 'dark' ? 'bg-blue-600' : 'bg-gray-600'
                        }`}
                      >
                        <div
                          className={`w-4 h-4 rounded-full bg-white transition-transform ${
                            preferences.theme === 'dark' ? 'translate-x-7' : 'translate-x-1'
                          }`}
                        />
                      </button>
                    </div>
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-2">
                        <Bell className="w-5 h-5 text-gray-400" />
                        <span>Notifications</span>
                      </div>
                      <button
                        onClick={() => handlePreferenceChange('notifications', !preferences.notifications)}
                        className={`w-12 h-6 rounded-full transition-colors ${
                          preferences.notifications ? 'bg-blue-600' : 'bg-gray-600'
                        }`}
                      >
                        <div
                          className={`w-4 h-4 rounded-full bg-white transition-transform ${
                            preferences.notifications ? 'translate-x-7' : 'translate-x-1'
                          }`}
                        />
                      </button>
                    </div>
                  </div>
                </div>

                {/* Control Settings */}
                <div>
                  <h3 className="text-lg font-medium mb-4">Control Settings</h3>
                  <div className="space-y-4">
                    <div>
                      <div className="flex items-center justify-between mb-2">
                        <div className="flex items-center gap-2">
                          <Sliders className="w-5 h-5 text-gray-400" />
                          <span>Control Sensitivity</span>
                        </div>
                        <span>{preferences.controlSettings.sensitivity}x</span>
                      </div>
                      <input
                        type="range"
                        min="0.1"
                        max="2"
                        step="0.1"
                        value={preferences.controlSettings.sensitivity}
                        onChange={(e) => handleControlSettingChange('sensitivity', parseFloat(e.target.value))}
                        className="w-full"
                      />
                    </div>
                    <div>
                      <div className="flex items-center justify-between mb-2">
                        <div className="flex items-center gap-2">
                          <Gauge className="w-5 h-5 text-gray-400" />
                          <span>Maximum Speed</span>
                        </div>
                        <span>{preferences.controlSettings.maxSpeed} m/s</span>
                      </div>
                      <input
                        type="range"
                        min="0.5"
                        max="5"
                        step="0.5"
                        value={preferences.controlSettings.maxSpeed}
                        onChange={(e) => handleControlSettingChange('maxSpeed', parseFloat(e.target.value))}
                        className="w-full"
                      />
                    </div>
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-2">
                        <AlertTriangle className="w-5 h-5 text-gray-400" />
                        <span>Safety Limits</span>
                      </div>
                      <button
                        onClick={() => handleControlSettingChange('safetyLimits', !preferences.controlSettings.safetyLimits)}
                        className={`w-12 h-6 rounded-full transition-colors ${
                          preferences.controlSettings.safetyLimits ? 'bg-blue-600' : 'bg-gray-600'
                        }`}
                      >
                        <div
                          className={`w-4 h-4 rounded-full bg-white transition-transform ${
                            preferences.controlSettings.safetyLimits ? 'translate-x-7' : 'translate-x-1'
                          }`}
                        />
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    );
  };

  ================
  File: src/components/Stats/StatsView.tsx
  ================
  import { useState, useEffect } from 'react';
  import { dummyApi } from '../../services/dummyApi';
  import type { RobotStats } from '../../types';
  import {
    Battery,
    Gauge,
    Thermometer,
    Cloud,
    Zap,
    Timer,
    Cpu,
    Signal,
    Navigation,
    AlertTriangle,
    Settings
  } from 'lucide-react';

  export const StatsView = () => {
    const [stats, setStats] = useState<RobotStats | null>(null);

    useEffect(() => {
      // Initial load
      loadStats();
      
      // Subscribe to updates
      const unsubscribe = dummyApi.subscribeToStats((newStats) => {
        setStats(newStats);
      });

      return () => {
        unsubscribe();
      };
    }, []);

    const loadStats = async () => {
      try {
        const currentStats = await dummyApi.getStats();
        setStats(currentStats);
      } catch (error) {
        console.error('Error loading stats:', error);
      }
    };

    const formatUptime = (seconds: number) => {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      return `${hours}h ${minutes}m`;
    };

    if (!stats) {
      return (
        <div className="flex justify-center items-center h-64">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
        </div>
      );
    }

    return (
      <div className="container mx-auto px-6 py-8">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {/* System Status */}
          <div className="bg-gray-800 rounded-lg p-6 col-span-full">
            <h2 className="text-xl font-semibold mb-4">System Status</h2>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <div className="bg-gray-700 rounded-lg p-4">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-gray-400">Status</span>
                  <div className="w-3 h-3 rounded-full bg-green-500"></div>
                </div>
                <div className="text-2xl font-bold">Online</div>
              </div>
              <div className="bg-gray-700 rounded-lg p-4">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-gray-400">Uptime</span>
                  <Timer className="w-5 h-5 text-blue-400" />
                </div>
                <div className="text-2xl font-bold">{formatUptime(stats.uptime)}</div>
              </div>
              <div className="bg-gray-700 rounded-lg p-4">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-gray-400">Errors</span>
                  <AlertTriangle className="w-5 h-5 text-yellow-400" />
                </div>
                <div className="text-2xl font-bold">{stats.errors}</div>
              </div>
              <div className="bg-gray-700 rounded-lg p-4">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-gray-400">Mode</span>
                  <Settings className="w-5 h-5 text-purple-400" />
                </div>
                <div className="text-2xl font-bold">{stats.mode}</div>
              </div>
            </div>
          </div>

          {/* Power Metrics */}
          <div className="bg-gray-800 rounded-lg p-6">
            <h2 className="text-xl font-semibold mb-4">Power</h2>
            <div className="space-y-6">
              <div>
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <Battery className="w-5 h-5 text-green-400" />
                    <span>Battery</span>
                  </div>
                  <span className="text-xl font-bold">{stats.battery}%</span>
                </div>
                <div className="h-2 bg-gray-700 rounded-full overflow-hidden">
                  <div 
                    className="h-full bg-green-400 rounded-full transition-all duration-500"
                    style={{ width: `${stats.battery}%` }}
                  ></div>
                </div>
              </div>
              <div>
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <Zap className="w-5 h-5 text-yellow-400" />
                    <span>Power Draw</span>
                  </div>
                  <span className="text-xl font-bold">{stats.powerConsumption}W</span>
                </div>
                <div className="h-2 bg-gray-700 rounded-full overflow-hidden">
                  <div 
                    className="h-full bg-yellow-400 rounded-full transition-all duration-500"
                    style={{ width: `${(stats.powerConsumption / 500) * 100}%` }}
                  ></div>
                </div>
              </div>
            </div>
          </div>

          {/* Environmental Metrics */}
          <div className="bg-gray-800 rounded-lg p-6">
            <h2 className="text-xl font-semibold mb-4">Environmental</h2>
            <div className="space-y-6">
              <div>
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <Thermometer className="w-5 h-5 text-red-400" />
                    <span>Temperature</span>
                  </div>
                  <span className="text-xl font-bold">{stats.temperature}Â°C</span>
                </div>
                <div className="h-2 bg-gray-700 rounded-full overflow-hidden">
                  <div 
                    className="h-full bg-red-400 rounded-full transition-all duration-500"
                    style={{ width: `${(stats.temperature / 100) * 100}%` }}
                  ></div>
                </div>
              </div>
              <div>
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <Cloud className="w-5 h-5 text-blue-400" />
                    <span>Humidity</span>
                  </div>
                  <span className="text-xl font-bold">{stats.humidity}%</span>
                </div>
                <div className="h-2 bg-gray-700 rounded-full overflow-hidden">
                  <div 
                    className="h-full bg-blue-400 rounded-full transition-all duration-500"
                    style={{ width: `${stats.humidity}%` }}
                  ></div>
                </div>
              </div>
            </div>
          </div>

          {/* Performance Metrics */}
          <div className="bg-gray-800 rounded-lg p-6">
            <h2 className="text-xl font-semibold mb-4">Performance</h2>
            <div className="space-y-6">
              <div>
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <Cpu className="w-5 h-5 text-purple-400" />
                    <span>CPU Usage</span>
                  </div>
                  <span className="text-xl font-bold">{stats.cpuUsage}%</span>
                </div>
                <div className="h-2 bg-gray-700 rounded-full overflow-hidden">
                  <div 
                    className="h-full bg-purple-400 rounded-full transition-all duration-500"
                    style={{ width: `${stats.cpuUsage}%` }}
                  ></div>
                </div>
              </div>
              <div>
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center gap-2">
                    <Gauge className="w-5 h-5 text-blue-400" />
                    <span>Speed</span>
                  </div>
                  <span className="text-xl font-bold">{stats.speed} m/s</span>
                </div>
                <div className="h-2 bg-gray-700 rounded-full overflow-hidden">
                  <div 
                    className="h-full bg-blue-400 rounded-full transition-all duration-500"
                    style={{ width: `${(stats.speed / 5) * 100}%` }}
                  ></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  };

  ================
  File: src/components/Users/UserItem.tsx
  ================
  import { useState } from 'react';
  import type { User } from '../../types';
  import { Edit2, Trash2, MoreVertical } from 'lucide-react';

  interface UserItemProps {
    user: User;
    onRoleChange: (userId: string, newRole: 'admin' | 'user') => Promise<void>;
  }

  export const UserItem = ({ user, onRoleChange }: UserItemProps) => {
    const [showActions, setShowActions] = useState(false);

    return (
      <div className="grid grid-cols-4 gap-4 p-4 items-center hover:bg-gray-700">
        <div className="flex items-center gap-3">
          <div className="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center">
            {user.displayName[0].toUpperCase()}
          </div>
          <span>{user.displayName}</span>
        </div>
        <div>{user.email}</div>
        <div>
          <select
            value={user.role}
            onChange={(e) => onRoleChange(user.id, e.target.value as 'admin' | 'user')}
            className="bg-gray-700 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="user">User</option>
            <option value="admin">Admin</option>
          </select>
        </div>
        <div className="relative">
          <button
            onClick={() => setShowActions(!showActions)}
            className="p-2 hover:bg-gray-600 rounded-lg transition"
          >
            <MoreVertical className="w-5 h-5" />
          </button>
          
          {showActions && (
            <div className="absolute right-0 mt-2 w-48 bg-gray-700 rounded-lg shadow-lg py-1 z-10">
              <button
                className="w-full px-4 py-2 text-left flex items-center gap-2 hover:bg-gray-600 transition"
              >
                <Edit2 className="w-4 h-4" />
                <span>Edit User</span>
              </button>
              <button
                className="w-full px-4 py-2 text-left flex items-center gap-2 hover:bg-gray-600 text-red-400 transition"
              >
                <Trash2 className="w-4 h-4" />
                <span>Delete User</span>
              </button>
            </div>
          )}
        </div>
      </div>
    );
  };

  ================
  File: src/components/Users/UserList.tsx
  ================
  import { useState, useEffect } from 'react';
  import { getAllUsers, updateUserProfile } from '../../services/firebase';
  import { UserItem } from './UserItem';
  import type { User } from '../../types';
  import { toast } from 'react-hot-toast';
  import { Users as UsersIcon, Search, Plus } from 'lucide-react';

  export const UserList = () => {
    const [users, setUsers] = useState<User[]>([]);
    const [searchTerm, setSearchTerm] = useState('');
    const [loading, setLoading] = useState(true);

    useEffect(() => {
      loadUsers();
    }, []);

    const loadUsers = async () => {
      try {
        const fetchedUsers = await getAllUsers();
        setUsers(fetchedUsers);
      } catch (error) {
        console.error('Error loading users:', error);
        toast.error('Failed to load users');
      } finally {
        setLoading(false);
      }
    };

    const handleRoleChange = async (userId: string, newRole: 'admin' | 'user') => {
      try {
        await updateUserProfile(userId, { role: newRole });
        setUsers(users.map(user => 
          user.id === userId ? { ...user, role: newRole } : user
        ));
        toast.success('User role updated successfully');
      } catch (error) {
        console.error('Error updating user role:', error);
        toast.error('Failed to update user role');
      }
    };

    const filteredUsers = users.filter(user =>
      user.displayName.toLowerCase().includes(searchTerm.toLowerCase()) ||
      user.email.toLowerCase().includes(searchTerm.toLowerCase())
    );

    if (loading) {
      return (
        <div className="flex justify-center items-center h-64">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
        </div>
      );
    }

    return (
      <div className="container mx-auto px-6 py-8">
        <div className="flex justify-between items-center mb-8">
          <div className="flex items-center gap-3">
            <UsersIcon className="w-6 h-6 text-blue-500" />
            <h1 className="text-2xl font-bold">Users Management</h1>
          </div>
          <button className="flex items-center gap-2 px-4 py-2 bg-blue-600 rounded-lg hover:bg-blue-700 transition">
            <Plus className="w-5 h-5" />
            <span>Add User</span>
          </button>
        </div>

        <div className="relative mb-6">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5" />
          <input
            type="text"
            placeholder="Search users..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="w-full pl-10 pr-4 py-2 bg-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
        </div>

        <div className="bg-gray-800 rounded-lg overflow-hidden">
          <div className="grid grid-cols-4 gap-4 p-4 border-b border-gray-700 font-semibold">
            <div>Name</div>
            <div>Email</div>
            <div>Role</div>
            <div>Actions</div>
          </div>
          <div className="divide-y divide-gray-700">
            {filteredUsers.map(user => (
              <UserItem 
                key={user.id} 
                user={user} 
                onRoleChange={handleRoleChange} 
              />
            ))}
          </div>
        </div>
      </div>
    );
  };

  ================
  File: src/config/firebase.config.ts
  ================
  export const firebaseConfig = {
    apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
    authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
    projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
    storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
    messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
    appId: import.meta.env.VITE_FIREBASE_APP_ID,
    databaseURL: import.meta.env.VITE_FIREBASE_DATABASE_URL
  };

  ================
  File: src/env.d.ts
  ================
  /// <reference types="vite/client" />

  interface ImportMetaEnv {
    readonly VITE_FIREBASE_API_KEY: string;
    readonly VITE_FIREBASE_AUTH_DOMAIN: string;
    readonly VITE_FIREBASE_PROJECT_ID: string;
    readonly VITE_FIREBASE_STORAGE_BUCKET: string;
    readonly VITE_FIREBASE_MESSAGING_SENDER_ID: string;
    readonly VITE_FIREBASE_APP_ID: string;
    readonly VITE_FIREBASE_DATABASE_URL: string;
  }

  interface ImportMeta {
    readonly env: ImportMetaEnv;
  }

  ================
  File: src/index.css
  ================
  @tailwind base;
  @tailwind components;
  @tailwind utilities;

  ================
  File: src/main.tsx
  ================
  import { StrictMode } from 'react';
  import { createRoot } from 'react-dom/client';
  import { RouterProvider } from 'react-router-dom';
  import { router } from './routes';
  import './index.css';

  createRoot(document.getElementById('root')!).render(
    <StrictMode>
      <RouterProvider router={router} />
    </StrictMode>
  );

  ================
  File: src/routes.tsx
  ================
  import { createBrowserRouter, Navigate } from 'react-router-dom';
  import { useAuth } from './components/Auth/AuthContext';
  import { LoginPage, RegisterPage } from './components/Auth';
  import { UserList } from './components/Users/UserList';
  import { ConfigPage } from './components/Config/ConfigPage';
  import { ControlView } from './components/Control/ControlView';
  import { StatsView } from './components/Stats/StatsView';
  import { ProfileView } from './components/Profile/ProfileView';
  import { NotificationsView } from './components/Notifications/NotificationsView';
  import App from './App';

  // Protected Route wrapper component
  const ProtectedRoute = ({ children, adminOnly = false }: { children: React.ReactNode; adminOnly?: boolean }) => {
    const { user, loading, isAdmin } = useAuth();

    if (loading) {
      return (
        <div className="flex justify-center items-center h-screen">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-white"></div>
        </div>
      );
    }

    if (!user) {
      return <Navigate to="/login" replace />;
    }

    if (adminOnly && !isAdmin) {
      return <Navigate to="/" replace />;
    }

    return <>{children}</>;
  };

  export const router = createBrowserRouter([
    {
      path: '/',
      element: <App />,
      children: [
        {
          path: '/',
          element: <Navigate to="/control" replace />,
        },
        {
          path: '/control',
          element: (
            <ProtectedRoute>
              <ControlView />
            </ProtectedRoute>
          ),
        },
        {
          path: '/stats',
          element: (
            <ProtectedRoute>
              <StatsView />
            </ProtectedRoute>
          ),
        },
        {
          path: '/profile',
          element: (
            <ProtectedRoute>
              <ProfileView />
            </ProtectedRoute>
          ),
        },
        {
          path: '/users',
          element: (
            <ProtectedRoute adminOnly>
              <UserList />
            </ProtectedRoute>
          ),
        },
        {
          path: '/config',
          element: (
            <ProtectedRoute adminOnly>
              <ConfigPage />
            </ProtectedRoute>
          ),
        },
        {
          path: '/login',
          element: <LoginPage />,
        },
        {
          path: '/register',
          element: <RegisterPage />,
        },
        {
          path: '/notifications',
          element: (
            <ProtectedRoute>
              <NotificationsView />
            </ProtectedRoute>
          ),
        },
      ],
    },
  ]);

  ================
  File: src/services/api.ts
  ================
  import axios ,{ AxiosResponse }from 'axios';
  import type { RobotStats } from '../types';

  const API_BASE_URL = 'http://localhost:5000/api';  // Replace with your Flask backend URL

  const api = axios.create({
    baseURL: API_BASE_URL,
    headers: {
      'Content-Type': 'application/json',
      //'Accept': 'application/json',
    },
    withCredentials: true // if using credentials
  });

  // Add auth token to requests
  api.interceptors.request.use((config) => {
    const token = localStorage.getItem('authToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  });

  interface LogEntry {
    operation: string;
    timestamp: string;
    userId: string;
  }

  export const robotApi = {
    // Connection endpoints
    connect: (ipAddress: string) =>
      api.post('/robot/connect', { ipAddress }),

    terminateSession: () =>
      api.post('/robot/terminate'),

    // Robot control endpoints
    sendCommand: (command: string) => 
      api.post('/robot/command', { command }),

    getStatus: () => 
      api.get<RobotStats>('/robot/status'),

    // Configuration endpoints
    updateConfig: (config: Record<string, any>) =>
      api.post('/robot/config', config),

    getConfig: () =>
      api.get('/robot/config'),

    // System endpoints
    getSystemLogs: (limit: number = 100) =>
      api.get('/system/logs', { params: { limit } }),

    checkConnection: () =>
      api.get('/system/health'),

      // Add the logs endpoint
      logOperation: (logEntry: LogEntry): Promise<AxiosResponse> =>
        api.post('/robot/logs', logEntry),
  };

  export default api;

  ================
  File: src/services/dummyApi.ts
  ================
  import type { RobotStats } from '../types';
  import type { Notification } from '../types/notifications';

  // Dummy stats data generator
  const generateDummyStats = (): RobotStats => ({
    battery: Math.floor(Math.random() * (100 - 20) + 20),
    temperature: Math.floor(Math.random() * (80 - 20) + 20),
    humidity: Math.floor(Math.random() * (100 - 30) + 30),
    cpuUsage: Math.floor(Math.random() * (100 - 10) + 10),
    powerConsumption: Math.floor(Math.random() * (500 - 100) + 100),
    speed: Number((Math.random() * 5).toFixed(1)),
    mode: ['Manual', 'Autonomous', 'Hybrid'][Math.floor(Math.random() * 3)],
    uptime: Math.floor(Math.random() * 86400), // Random seconds up to 24 hours
    errors: Math.floor(Math.random() * 5),
  });

  // Dummy notifications data
  const dummyNotifications: Notification[] = [
    {
      id: '1',
      title: 'Battery Low',
      message: 'Robot battery level is below 20%. Please connect to charging station.',
      type: 'warning',
      timestamp: new Date(Date.now() - 1000 * 60 * 5).toISOString(), // 5 minutes ago
      read: false,
    },
    {
      id: '2',
      title: 'Operation Completed',
      message: 'Scheduled maintenance routine has been completed successfully.',
      type: 'success',
      timestamp: new Date(Date.now() - 1000 * 60 * 30).toISOString(), // 30 minutes ago
      read: true,
    },
    {
      id: '3',
      title: 'System Update',
      message: 'New firmware version 2.1.0 is available for installation.',
      type: 'info',
      timestamp: new Date(Date.now() - 1000 * 60 * 60 * 2).toISOString(), // 2 hours ago
      read: false,
    },
    {
      id: '4',
      title: 'Connection Lost',
      message: 'Temporary connection loss detected. Reconnected automatically.',
      type: 'error',
      timestamp: new Date(Date.now() - 1000 * 60 * 60 * 5).toISOString(), // 5 hours ago
      read: true,
    },
    {
      id: '5',
      title: 'Temperature Warning',
      message: 'Motor temperature exceeding normal operating range.',
      type: 'warning',
      timestamp: new Date(Date.now() - 1000 * 60 * 60 * 24).toISOString(), // 1 day ago
      read: false,
    },
  ];

  // Simulated API delay
  const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

  export const dummyApi = {
    // Stats API
    getStats: async (): Promise<RobotStats> => {
      await delay(800); // Simulate network delay
      return generateDummyStats();
    },

    subscribeToStats: (callback: (stats: RobotStats) => void) => {
      // Update stats every 5 seconds
      const interval = setInterval(() => {
        callback(generateDummyStats());
      }, 5000);

      return () => clearInterval(interval);
    },

    // Notifications API
    getNotifications: async (): Promise<Notification[]> => {
      await delay(1000);
      return [...dummyNotifications].sort(
        (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
      );
    },

    markAsRead: async (notificationId: string): Promise<void> => {
      await delay(500);
      const notification = dummyNotifications.find(n => n.id === notificationId);
      if (notification) {
        notification.read = true;
      }
    },

    markAllAsRead: async (): Promise<void> => {
      await delay(800);
      dummyNotifications.forEach(notification => {
        notification.read = true;
      });
    },

    deleteNotification: async (notificationId: string): Promise<void> => {
      await delay(500);
      const index = dummyNotifications.findIndex(n => n.id === notificationId);
      if (index !== -1) {
        dummyNotifications.splice(index, 1);
      }
    },
  };

  ================
  File: src/services/firebase.ts
  ================
  import { initializeApp } from 'firebase/app';
  import { 
    getAuth, 
    signInWithEmailAndPassword, 
    createUserWithEmailAndPassword,
    signOut,
    onAuthStateChanged,
    User as FirebaseUser 
  } from 'firebase/auth';
  import { 
    getDatabase, 
    ref, 
    set, 
    get,
    update 
  } from 'firebase/database';
  import type { User, UserPreferences } from '../types';
  import { firebaseConfig } from '../config/firebase.config';

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const database = getDatabase(app);

  // Auth functions
  export const loginUser = async (email: string, password: string) => {
    const userCredential = await signInWithEmailAndPassword(auth, email, password);
    
    // Update last login time
    await update(ref(database, `users/${userCredential.user.uid}`), {
      lastLogin: new Date().toISOString(),
      role: isAdminEmail(email) ? 'admin' : 'user' // Ensure admin role is set on login
    });
    
    return userCredential;
  };

  export const registerUser = async (email: string, password: string, displayName: string) => {
    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
    const user = userCredential.user;
    
    // Create user profile in realtime database
    await set(ref(database, `users/${user.uid}`), {
      email,
      displayName,
      role: email === 'shakhawat.swe@gmail.com' ? 'admin' : 'user',
      createdAt: new Date().toISOString(),
      lastLogin: new Date().toISOString()
    });

    return userCredential;
  };

  export const logoutUser = () => {
    return signOut(auth);
  };

  export const getCurrentUser = (): Promise<FirebaseUser | null> => {
    return new Promise((resolve, reject) => {
      const unsubscribe = onAuthStateChanged(
        auth,
        (user) => {
          unsubscribe();
          resolve(user);
        },
        reject
      );
    });
  };

  // Database functions
  export const getUserProfile = async (userId: string): Promise<User | null> => {
    const snapshot = await get(ref(database, `users/${userId}`));
    const userData = snapshot.val();
    if (userData) {
      // Ensure admin role is set correctly based on email
      if (isAdminEmail(userData.email)) {
        userData.role = 'admin';
        // Update the role in database if it's not correct
        if (userData.role !== 'admin') {
          await update(ref(database, `users/${userId}`), { role: 'admin' });
        }
      }
    }
    return userData;
  };

  export const updateUserProfile = async (userId: string, data: Partial<User>) => {
    return update(ref(database, `users/${userId}`), data);
  };

  export const getUserPreferences = async (userId: string): Promise<UserPreferences | null> => {
    const snapshot = await get(ref(database, `preferences/${userId}`));
    return snapshot.val();
  };

  export const updateUserPreferences = async (userId: string, preferences: Partial<UserPreferences>) => {
    return update(ref(database, `preferences/${userId}`), preferences);
  };

  export const getAllUsers = async (): Promise<User[]> => {
    const snapshot = await get(ref(database, 'users'));
    return Object.values(snapshot.val() || {});
  };

  // Add a function to check if a user is admin
  export const isAdminEmail = (email: string) => {
    return email === 'shakhawat.swe@gmail.com';
  };

  export { auth, database };

  ================
  File: src/services/robotService.ts
  ================
  import { robotApi } from './api';
  import { database, getCurrentUser } from './firebase';
  import { ref, onValue, off } from 'firebase/database';
  import type { RobotStats } from '../types';

  class RobotService {
    private statsListener: any = null;
    private currentIp: string | null = null;

    // Connect to robot
    async connect(ipAddress: string): Promise<void> {
      try {
        await robotApi.connect(ipAddress);
        this.currentIp = ipAddress;
      } catch (error) {
        console.error('Error connecting to robot:', error);
        throw error;
      }
    }

    // Send control commands to the robot
    async sendCommand(command: string): Promise<void> {
      if (!this.currentIp) {
        throw new Error('Not connected to robot');
      }

      try {
        await robotApi.sendCommand(command);
        await this.logOperation(`Sent command: ${command}`);
      } catch (error) {
        console.error('Error sending command:', error);
        throw error;
      }
    }

    // Terminate session
    async terminateSession(): Promise<void> {
      if (!this.currentIp) {
        throw new Error('Not connected to robot');
      }

      try {
        await robotApi.terminateSession();
        this.currentIp = null;
        await this.logOperation('Session terminated');
      } catch (error) {
        console.error('Error terminating session:', error);
        throw error;
      }
    }

    // Get current robot stats
    async getRobotStats(): Promise<RobotStats> {
      try {
        const response = await robotApi.getStatus();
        return response.data;
      } catch (error) {
        console.error('Error getting robot stats:', error);
        throw error;
      }
    }

    // Subscribe to real-time robot stats updates
    subscribeToStats(callback: (stats: RobotStats) => void): void {
      const statsRef = ref(database, 'robotStats');
      this.statsListener = onValue(statsRef, (snapshot) => {
        const stats = snapshot.val();
        callback(stats);
      });
    }

    // Unsubscribe from stats updates
    unsubscribeFromStats(): void {
      if (this.statsListener) {
        const statsRef = ref(database, 'robotStats');
        off(statsRef, 'value', this.statsListener);
        this.statsListener = null;
      }
    }

    // Log robot operation
    async logOperation(operation: string): Promise<void> {
      const user = await getCurrentUser();
      if (!user) throw new Error('No user logged in');

      const logEntry = {
        operation,
        timestamp: new Date().toISOString(),
        userId: user.uid,
      };

      try {
        await robotApi.logOperation(logEntry);
      } catch (error) {
        console.error('Error logging operation:', error);
        throw error;
      }
    }
  }

  export const robotService = new RobotService();
  export default robotService;

  ================
  File: src/types/index.ts
  ================
  export interface User {
    id: string;
    email: string;
    displayName: string;
    role: 'admin' | 'user';
    createdAt: string;
    lastLogin: string;
  }

  export interface RobotStats {
    battery: number;
    speed: number;
    mode: 'Manual' | 'Autonomous';
    temperature: number;
    humidity: number;
    powerConsumption: number;
    batteryCapacity: number;
    cpuUsage: number;
    signalStrength: number;
    gpsAccuracy: number;
    uptime: number;
    errors: number;
  }

  export interface UserPreferences {
    userId: string;
    theme: 'light' | 'dark';
    notifications: boolean;
    controlSettings: {
      sensitivity: number;
      maxSpeed: number;
      safetyLimits: boolean;
    };
    dashboardLayout: string[];
  }

  ================
  File: src/types/notifications.ts
  ================
  export interface Notification {
    id: string;
    title: string;
    message: string;
    type: 'info' | 'warning' | 'error' | 'success';
    timestamp: string;
    read: boolean;
  }

  ================
  File: src/vite-env.d.ts
  ================
  /// <reference types="vite/client" />

  ================
  File: tailwind.config.js
  ================
  /** @type {import('tailwindcss').Config} */
  export default {
    content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
    theme: {
      extend: {},
    },
    plugins: [],
  };

  ================
  File: tsconfig.app.json
  ================
  {
    "compilerOptions": {
      "target": "ES2020",
      "useDefineForClassFields": true,
      "lib": ["ES2020", "DOM", "DOM.Iterable"],
      "module": "ESNext",
      "skipLibCheck": true,

      /* Bundler mode */
      "moduleResolution": "bundler",
      "allowImportingTsExtensions": true,
      "isolatedModules": true,
      "moduleDetection": "force",
      "noEmit": true,
      "jsx": "react-jsx",

      /* Linting */
      "strict": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "noFallthroughCasesInSwitch": true
    },
    "include": ["src"]
  }

  ================
  File: tsconfig.json
  ================
  {
    "files": [],
    "references": [
      { "path": "./tsconfig.app.json" },
      { "path": "./tsconfig.node.json" }
    ]
  }

  ================
  File: tsconfig.node.json
  ================
  {
    "compilerOptions": {
      "target": "ES2022",
      "lib": ["ES2023"],
      "module": "ESNext",
      "skipLibCheck": true,

      /* Bundler mode */
      "moduleResolution": "bundler",
      "allowImportingTsExtensions": true,
      "isolatedModules": true,
      "moduleDetection": "force",
      "noEmit": true,

      /* Linting */
      "strict": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "noFallthroughCasesInSwitch": true
    },
    "include": ["vite.config.ts"]
  }

  ================
  File: vite.config.ts
  ================
  // 
  // vite.config.ts
  import { defineConfig } from 'vite';
  import react from '@vitejs/plugin-react';

  export default defineConfig({
      plugins: [react()],
      server: {
          proxy: {
              '/api': {
                  target: 'http://localhost:5000',
                  changeOrigin: true,
                  secure: false,
                  ws: true,
              }
          }
      },
      optimizeDeps: {
          exclude: ['lucide-react'],
      },
  });





the codebase of go2-webrtc-connect that has examples scripts. you will analyze it whene developing scripts:


	================================================================
	File Summary
	================================================================



	File Format:
	------------
	The content is organized as follows:
	1. This summary section
	2. Repository information
	3. Repository structure
	4. Multiple file entries, each consisting of:
	  a. A separator line (================)
	  b. The file path (File: path/to/file)
	  c. Another separator line
	  d. The full contents of the file
	  e. A blank line



	================================================================
	Repository Structure
	================================================================
	.gitignore
	.gitmodules
	examples/audio/internet_radio/stream_radio.py
	examples/audio/live_audio/live_recv_audio.py
	examples/audio/mp3_player/play_mp3.py
	examples/audio/mp3_player/webrtc_audio_player.py
	examples/audio/save_audio/save_audio_to_file.py
	examples/data_channel/lidar/lidar_stream.py
	examples/data_channel/lowstate/lowstate.py
	examples/data_channel/multiplestate/multiplestate.py
	examples/data_channel/sportmode/sportmode.py
	examples/data_channel/sportmodestate/sportmodestate.py
	examples/data_channel/vui/vui.py
	examples/video/camera_stream/display_video_channel.py
	go2_webrtc_driver/__init__.py
	go2_webrtc_driver/constants.py
	go2_webrtc_driver/encryption.py
	go2_webrtc_driver/lidar/lidar_decoder_points.py
	go2_webrtc_driver/lidar/lidar_decoder.py
	go2_webrtc_driver/msgs/error_handler.py
	go2_webrtc_driver/msgs/future_resolver.py
	go2_webrtc_driver/msgs/heartbeat.py
	go2_webrtc_driver/msgs/pub_sub.py
	go2_webrtc_driver/msgs/rtc_inner_req.py
	go2_webrtc_driver/msgs/validation.py
	go2_webrtc_driver/multicast_scanner.py
	go2_webrtc_driver/unitree_auth.py
	go2_webrtc_driver/util.py
	go2_webrtc_driver/webrtc_audio.py
	go2_webrtc_driver/webrtc_audiohub.py
	go2_webrtc_driver/webrtc_datachannel.py
	go2_webrtc_driver/webrtc_driver.py
	go2_webrtc_driver/webrtc_video.py
	README.md
	setup.py

	================================================================
	Repository Files
	================================================================

	================
	File: .gitignore
	================
	# Ignore Python bytecode
	__pycache__/
	*.py[cod]
	# Logs and runtime files
	log/

	# Ignore the re/ directory
	re/

	# Ignore egg-info directories
	*.egg-info/

	# Ignore OS specific files
	.DS_Store
	Thumbs.db

	# Ignore virtual environments (if applicable)
	venv/
	env/

	# Ignore IDE specific files (optional, if you're using an IDE like PyCharm, VS Code, etc.)
	.idea/
	.vscode/

	output.wav
	output_video.mp4

	build/

	================
	File: .gitmodules
	================
	[submodule "libs/aioice"]
		path = libs/aioice
		url = https://github.com/legion1581/aioice.git
		branch = go2

	================
	File: examples/audio/internet_radio/stream_radio.py
	================
	import logging
	import asyncio
	import sys
	from go2_webrtc_driver.webrtc_driver import Go2WebRTCConnection, WebRTCConnectionMethod
	from aiortc.contrib.media import MediaPlayer


	# Enable logging for debugging
	logging.basicConfig(level=logging.FATAL)

	async def main():
		try:
			conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, ip="192.168.8.181")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, serialNumber="B42D2000XXXXXXXX")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.Remote, serialNumber="B42D2000XXXXXXXX", username="email@gmail.com", password="pass")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalAP)
			
			await conn.connect()

			stream_url = "https://nashe1.hostingradio.ru:80/ultra-128.mp3" #Radio ultra

			logging.info(f"Playing internet radio: {stream_url}")
			player = MediaPlayer(stream_url)  # Use MediaPlayer with the URL
			audio_track = player.audio  # Get the audio track from the player
			conn.pc.addTrack(audio_track)  # Add the audio track to the WebRTC connection

			await asyncio.sleep(3600)  # Keep the program running to handle events

		except ValueError as e:
			logging.error(e)

	if __name__ == "__main__":
		try:
			asyncio.run(main())
		except KeyboardInterrupt:
			# Handle Ctrl+C to exit gracefully.
			print("\nProgram interrupted by user")
			sys.exit(0)

	================
	File: examples/audio/live_audio/live_recv_audio.py
	================
	import asyncio
	import logging
	import numpy as np
	import pyaudio
	import sys
	from go2_webrtc_driver.webrtc_driver import Go2WebRTCConnection, WebRTCConnectionMethod
	from go2_webrtc_driver.webrtc_video import MediaHandler

	# Enable logging for debugging
	logging.basicConfig(level=logging.FATAL)

	# Define the audio properties
	samplerate = 48000  # Sample rate for WebRTC audio
	channels = 2  # Stereo audio
	frames_per_buffer = 8192  # Number of frames per buffer for PyAudio

	# Initialize PyAudio
	p = pyaudio.PyAudio()

	# Open a PyAudio stream to output audio
	stream = p.open(format=pyaudio.paInt16,
					channels=channels,
					rate=samplerate,
					output=True,
					frames_per_buffer=frames_per_buffer)

	# Function to handle receiving audio frames and play them through the speakers
	async def recv_audio_stream(frame):
		# Convert the frame to audio data (assuming 16-bit PCM)
		audio_data = np.frombuffer(frame.to_ndarray(), dtype=np.int16)

		# Play the audio data by writing it to the PyAudio stream
		stream.write(audio_data.tobytes())

	# Main function for setting up the WebRTC connection and handling streams
	async def main():
		try:
			# Choose a connection method (uncomment the correct one)
			conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, ip="192.168.8.181")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, serialNumber="B42D2000XXXXXXXX")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.Remote, serialNumber="B42D2000XXXXXXXX", username="email@gmail.com", password="pass")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalAP)

			# Connect to the device
			await conn.connect()

			# Switch audio channel on and start receiving audio frames
			conn.audio.switchAudioChannel(True)

			# Add callback to handle received audio frames
			conn.audio.add_track_callback(recv_audio_stream)

			# Keep the program running to handle events
			await asyncio.sleep(3600)  # Keep running for 1 hour or as needed

		except ValueError as e:
			logging.error(f"Error in WebRTC connection: {e}")

		finally:
			# Stop and close the PyAudio stream when done
			stream.stop_stream()
			stream.close()
			p.terminate()

	if __name__ == "__main__":
		try:
			asyncio.run(main())
		except KeyboardInterrupt:
			# Handle Ctrl+C to exit gracefully.
			print("\nProgram interrupted by user")
			sys.exit(0)

	================
	File: examples/audio/mp3_player/play_mp3.py
	================
	import logging
	import asyncio
	import os 
	import sys
	from go2_webrtc_driver.webrtc_driver import Go2WebRTCConnection, WebRTCConnectionMethod
	from aiortc.contrib.media import MediaPlayer


	# Enable logging for debugging
	logging.basicConfig(level=logging.FATAL)

	async def main():
		try:
			# Choose a connection method (uncomment the correct one)
			conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, ip="192.168.8.181")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, serialNumber="B42D2000XXXXXXXX")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.Remote, serialNumber="B42D2000XXXXXXXX", username="email@gmail.com", password="pass")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalAP)
			
			await conn.connect()

			
			mp3_path = os.path.join(os.path.dirname(__file__), "dora-doradura-mp3.mp3")
			
			logging.info(f"Playing MP3: {mp3_path}")
			player = MediaPlayer(mp3_path)  # Use MediaPlayer for MP3
			audio_track = player.audio  # Get the audio track from the player
			conn.pc.addTrack(audio_track)  # Add the audio track to the WebRTC connection

			await asyncio.sleep(3600)  # Keep the program running to handle events

		except ValueError as e:
			# Log any value errors that occur during the process.
			logging.error(f"An error occurred: {e}")

	if __name__ == "__main__":
		try:
			asyncio.run(main())
		except KeyboardInterrupt:
			# Handle Ctrl+C to exit gracefully.
			print("\nProgram interrupted by user")
			sys.exit(0)

	================
	File: examples/audio/mp3_player/webrtc_audio_player.py
	================
	import logging
	import asyncio
	import os
	import json
	from go2_webrtc_driver.webrtc_driver import Go2WebRTCConnection, WebRTCConnectionMethod
	from go2_webrtc_driver.webrtc_audiohub import WebRTCAudioHub

	# Enable logging for debugging
	logging.basicConfig(level=logging.ERROR)
	logger = logging.getLogger(__name__)

	async def main():
		try:
			# Establish WebRTC connection
			conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, ip="192.168.137.120")
			await conn.connect()
			logger.info("WebRTC connection established")

			# Create audio hub instance
			audio_hub = WebRTCAudioHub(conn, logger)
			logger.info("Audio hub initialized")

			# Define audio file to upload and play
			audio_file = "dog-barking.wav"
			audio_file_path = os.path.join(os.path.dirname(__file__), audio_file)
			logger.info(f"Using audio file: {audio_file_path}")

			# Get the list of available audio files
			response = await audio_hub.get_audio_list()
			if response and isinstance(response, dict):
				data_str = response.get('data', {}).get('data', '{}')
				audio_list = json.loads(data_str).get('audio_list', [])
				
				# Extract filename without extension
				filename = os.path.splitext(audio_file)[0]
				print(audio_list)
				# Check if file already exists by CUSTOM_NAME and store UUID
				existing_audio = next((audio for audio in audio_list if audio['CUSTOM_NAME'] == filename), None)
				if existing_audio:
					print(f"Audio file {filename} already exists, skipping upload")
					uuid = existing_audio['UNIQUE_ID']
				else:
					print(f"Audio file {filename} not found, proceeding with upload")
					uuid = None

					# Upload the audio file
					logger.info("Starting audio file upload...")
					await audio_hub.upload_audio_file(audio_file_path)
					logger.info("Audio file upload completed")
					response = await audio_hub.get_audio_list()
					existing_audio = next((audio for audio in audio_list if audio['CUSTOM_NAME'] == filename), None)
					uuid = existing_audio['UNIQUE_ID']

			# Play the uploaded audio file using its filename as UUID
			
			print(f"Starting audio playback of file: {uuid}")
			await audio_hub.play_by_uuid(uuid)
			logger.info("Audio playback completed")



		except Exception as e:
			logger.error(f"An error occurred: {e}")

	if __name__ == "__main__":
		try:
			asyncio.run(main())
		except KeyboardInterrupt:
			logger.info("Program terminated by user")

	================
	File: examples/audio/save_audio/save_audio_to_file.py
	================
	import asyncio
	import logging
	import wave
	import numpy as np
	import sys
	from go2_webrtc_driver.webrtc_driver import Go2WebRTCConnection, WebRTCConnectionMethod
	from go2_webrtc_driver.webrtc_video import MediaHandler

	# Enable logging for debugging
	logging.basicConfig(level=logging.FATAL)

	# Define the audio properties
	samplerate = 48000  # Sample rate for WebRTC audio
	channels = 2  # Stereo audio
	filename = "output.wav"
	record_duration = 5 # Record for 5 seconds
	total_frames_to_record = record_duration * samplerate  # Total frames for the specified duration
	frames_recorded = 0  # Counter for the number of frames recorded
	done_writing_to_file = False  # Flag to indicate when writing is done

	# Open the WAV file once for the entire duration
	wf = wave.open(filename, 'wb')
	wf.setnchannels(channels)
	wf.setsampwidth(2)  # 2 bytes (16 bits) per sample
	wf.setframerate(samplerate)

	# Function to handle receiving audio frames and write them directly to file
	async def recv_audio_stream(frame):
		global frames_recorded, done_writing_to_file

		if done_writing_to_file:
			return

		# Convert the frame to audio data (assuming 16-bit PCM)
		audio_data = np.frombuffer(frame.to_ndarray(), dtype=np.int16)

		# Write the audio data directly to the WAV file
		wf.writeframes(audio_data.tobytes())

		# Update the frame counter
		frames_recorded += len(audio_data) // channels

		# If we've recorded enough frames, stop further recording
		if frames_recorded >= total_frames_to_record:
			# Close the WAV file
			wf.close()
			print(f"Audio recording complete, saved to {filename}")
			done_writing_to_file = True

	# Main function for setting up the WebRTC connection and handling streams
	async def main():
		try:
			# Choose a connection method (uncomment the correct one)
			conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, ip="192.168.8.181")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, serialNumber="B42D2000XXXXXXXX")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.Remote, serialNumber="B42D2000XXXXXXXX", username="email@gmail.com", password="pass")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalAP)

			# Connect to the device
			await conn.connect()

			# Switch audio channel on and start receiving audio frames
			conn.audio.switchAudioChannel(True)

			# Add callback to handle received audio frames
			conn.audio.add_track_callback(recv_audio_stream)

			# Keep the program running to handle events
			await asyncio.sleep(record_duration + 1)  # Allow extra time to process the recording

		except ValueError as e:
			logging.error(f"Error in WebRTC connection: {e}")

	if __name__ == "__main__":
		try:
			asyncio.run(main())
		except KeyboardInterrupt:
			# Handle Ctrl+C to exit gracefully.
			print("\nProgram interrupted by user")
			sys.exit(0)

	================
	File: examples/data_channel/lidar/lidar_stream.py
	================
	import asyncio
	import logging
	import sys
	from go2_webrtc_driver.webrtc_driver import Go2WebRTCConnection, WebRTCConnectionMethod

	# Enable logging for debugging
	logging.basicConfig(level=logging.FATAL)
		
	async def main():
		try:
			# Choose a connection method (uncomment the correct one)
			conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, ip="192.168.8.181")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, serialNumber="B42D2000XXXXXXXX")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.Remote, serialNumber="B42D2000XXXXXXXX", username="email@gmail.com", password="pass")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalAP)

			# Connect to the WebRTC service.
			await conn.connect()

			# Disable traffic saving mode on the data channel.
			await conn.datachannel.disableTrafficSaving(True)

			# Publish a message to turn the LIDAR sensor on.
			conn.datachannel.pub_sub.publish_without_callback("rt/utlidar/switch", "on")

			# Define a callback function to handle LIDAR messages when received.
			def lidar_callback(message):
				# Print the data received from the LIDAR sensor.
				print(message["data"])

			# Subscribe to the LIDAR voxel map data and use the callback function to process incoming messages.
			conn.datachannel.pub_sub.subscribe("rt/utlidar/voxel_map_compressed", lidar_callback)

			# Keep the program running to allow event handling for 1 hour.
			await asyncio.sleep(3600)
		
		except ValueError as e:
			# Log any value errors that occur during the process.
			logging.error(f"An error occurred: {e}")

	if __name__ == "__main__":
		try:
			asyncio.run(main())
		except KeyboardInterrupt:
			# Handle Ctrl+C to exit gracefully.
			print("\nProgram interrupted by user")
			sys.exit(0)

	================
	File: examples/data_channel/lowstate/lowstate.py
	================
	import asyncio
	import logging
	import sys
	from go2_webrtc_driver.webrtc_driver import Go2WebRTCConnection, WebRTCConnectionMethod
	from go2_webrtc_driver.constants import RTC_TOPIC

	# Enable logging for debugging
	logging.basicConfig(level=logging.FATAL)

	def display_data(message):

		# Extracting data from the message
		imu_state = message['imu_state']['rpy']
		motor_state = message['motor_state']
		bms_state = message['bms_state']
		foot_force = message['foot_force']
		temperature_ntc1 = message['temperature_ntc1']
		power_v = message['power_v']

		# Clear the entire screen and reset cursor position to top
		sys.stdout.write("\033[H\033[J")

		# Print the Go2 Robot Status
		print("Go2 Robot Status (LowState)")
		print("===========================")

		# IMU State (RPY)
		print(f"IMU - RPY: Roll: {imu_state[0]}, Pitch: {imu_state[1]}, Yaw: {imu_state[2]}")

	  # Compact Motor States Display (Each motor on one line)
		print("\nMotor States (q, Temperature, Lost):")
		print("------------------------------------------------------------")
		for i, motor in enumerate(motor_state):
			# Display motor info in a single line
			print(f"Motor {i + 1:2}: q={motor['q']:.4f}, Temp={motor['temperature']}Â°C, Lost={motor['lost']}")

		# BMS (Battery Management System) State
		print("\nBattery Management System (BMS) State:")
		print(f"  Version: {bms_state['version_high']}.{bms_state['version_low']}")
		print(f"  SOC (State of Charge): {bms_state['soc']}%")
		print(f"  Current: {bms_state['current']} mA")
		print(f"  Cycle Count: {bms_state['cycle']}")
		print(f"  BQ NTC: {bms_state['bq_ntc']}Â°C")
		print(f"  MCU NTC: {bms_state['mcu_ntc']}Â°C")

		# Foot Force
		print(f"\nFoot Force: {foot_force}")

		# Additional Sensors
		print(f"Temperature NTC1: {temperature_ntc1}Â°C")
		print(f"Power Voltage: {power_v}V")

		# Optionally, flush to ensure immediate output
		sys.stdout.flush()



	async def main():
		try:
			# Choose a connection method (uncomment the correct one)
			conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, ip="192.168.8.181")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, serialNumber="B42D2000XXXXXXXX")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.Remote, serialNumber="B42D2000XXXXXXXX", username="email@gmail.com", password="pass")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalAP)

			# Connect to the WebRTC service.
			await conn.connect()


			# Define a callback function to handle lowstate status when received.
			def lowstate_callback(message):
				current_message = message['data']
				
				display_data(current_message)


			# Subscribe to the sportmode status data and use the callback function to process incoming messages.
			conn.datachannel.pub_sub.subscribe(RTC_TOPIC['LOW_STATE'], lowstate_callback)


			# Keep the program running to allow event handling for 1 hour.
			await asyncio.sleep(3600)

		except ValueError as e:
			# Log any value errors that occur during the process.
			logging.error(f"An error occurred: {e}")


	if __name__ == "__main__":
		try:
			asyncio.run(main())
		except KeyboardInterrupt:
			# Handle Ctrl+C to exit gracefully.
			print("\nProgram interrupted by user")
			sys.exit(0)

	================
	File: examples/data_channel/multiplestate/multiplestate.py
	================
	import asyncio
	import logging
	import sys
	import json
	from go2_webrtc_driver.webrtc_driver import Go2WebRTCConnection, WebRTCConnectionMethod
	from go2_webrtc_driver.constants import RTC_TOPIC

	# Enable logging for debugging
	logging.basicConfig(level=logging.FATAL)

	def display_data(message):

		message = json.loads(message)
		
		body_height = message['bodyHeight']
		brightness = message['brightness']
		foot_raise_height = message['footRaiseHeight']
		obstacles_avoid_switch = message['obstaclesAvoidSwitch']
		speed_level = message['speedLevel']
		uwb_switch = message['uwbSwitch']
		volume = message['volume']

		# Clear the entire screen and reset cursor position to top
		sys.stdout.write("\033[H\033[J")

		# Print each piece of data on a separate line
		print("Go2 Multiple Robot Status")
		print("===================")
		print(f"Body Height:           {body_height:.2f} meters")
		print(f"Brightness:            {brightness}")
		print(f"Foot Raise Height:     {foot_raise_height:.2f} meters")
		print(f"Obstacles Avoid Switch: {'Enabled' if obstacles_avoid_switch else 'Disabled'}")
		print(f"Speed Level:           {speed_level}")
		print(f"UWB Switch:            {'On' if uwb_switch else 'Off'}")
		print(f"Volume:                {volume}/10")
		print("===================")
		
		# Optionally, flush to ensure immediate output
		sys.stdout.flush()

	async def main():
		try:
			# Choose a connection method (uncomment the correct one)
			conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, ip="192.168.8.181")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, serialNumber="B42D2000XXXXXXXX")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.Remote, serialNumber="B42D2000XXXXXXXX", username="email@gmail.com", password="pass")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalAP)

			# Connect to the WebRTC service.
			await conn.connect()


			# Define a callback function to handle multiplestate when received.
			def multiplestate_callback(message):
				current_message = message['data']
				
				display_data(current_message)


			# Subscribe to the multiplestate data and use the callback function to process incoming messages.
			conn.datachannel.pub_sub.subscribe(RTC_TOPIC['MULTIPLE_STATE'], multiplestate_callback)


			# Keep the program running to allow event handling for 1 hour.
			await asyncio.sleep(3600)

		except ValueError as e:
			# Log any value errors that occur during the process.
			logging.error(f"An error occurred: {e}")


	if __name__ == "__main__":
		try:
			asyncio.run(main())
		except KeyboardInterrupt:
			# Handle Ctrl+C to exit gracefully.
			print("\nProgram interrupted by user")
			sys.exit(0)

	================
	File: examples/data_channel/sportmode/sportmode.py
	================
	import asyncio
	import logging
	import json
	import sys
	from go2_webrtc_driver.webrtc_driver import Go2WebRTCConnection, WebRTCConnectionMethod
	from go2_webrtc_driver.constants import RTC_TOPIC, SPORT_CMD

	# Enable logging for debugging
	logging.basicConfig(level=logging.FATAL)
		
	async def main():
		try:
			# Choose a connection method (uncomment the correct one)
			conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, ip="192.168.8.181")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, serialNumber="B42D2000XXXXXXXX")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.Remote, serialNumber="B42D2000XXXXXXXX", username="email@gmail.com", password="pass")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalAP)

			# Connect to the WebRTC service.
			await conn.connect()

			####### NORMAL MODE ########
			print("Checking current motion mode...")

			# Get the current motion_switcher status
			response = await conn.datachannel.pub_sub.publish_request_new(
				RTC_TOPIC["MOTION_SWITCHER"], 
				{"api_id": 1001}
			)

			if response['data']['header']['status']['code'] == 0:
				data = json.loads(response['data']['data'])
				current_motion_switcher_mode = data['name']
				print(f"Current motion mode: {current_motion_switcher_mode}")

			# Switch to "normal" mode if not already
			if current_motion_switcher_mode != "normal":
				print(f"Switching motion mode from {current_motion_switcher_mode} to 'normal'...")
				await conn.datachannel.pub_sub.publish_request_new(
					RTC_TOPIC["MOTION_SWITCHER"], 
					{
						"api_id": 1002,
						"parameter": {"name": "normal"}
					}
				)
				await asyncio.sleep(5)  # Wait while it stands up

			# Perform a "Hello" movement
			print("Performing 'Hello' movement...")
			await conn.datachannel.pub_sub.publish_request_new(
				RTC_TOPIC["SPORT_MOD"], 
				{"api_id": SPORT_CMD["Hello"]}
			)

			await asyncio.sleep(1)

			# Perform a "Move Forward" movement
			print("Moving forward...")
			await conn.datachannel.pub_sub.publish_request_new(
				RTC_TOPIC["SPORT_MOD"], 
				{
					"api_id": SPORT_CMD["Move"],
					"parameter": {"x": 0.5, "y": 0, "z": 0}
				}
			)

			await asyncio.sleep(3)

			# Perform a "Move Backward" movement
			print("Moving backward...")
			await conn.datachannel.pub_sub.publish_request_new(
				RTC_TOPIC["SPORT_MOD"], 
				{
					"api_id": SPORT_CMD["Move"],
					"parameter": {"x": -0.5, "y": 0, "z": 0}
				}
			)

			await asyncio.sleep(3)

			####### AI MODE ########

			# Switch to AI mode
			print("Switching motion mode to 'AI'...")
			await conn.datachannel.pub_sub.publish_request_new(
				RTC_TOPIC["MOTION_SWITCHER"], 
				{
					"api_id": 1002,
					"parameter": {"name": "ai"}
				}
			)
			await asyncio.sleep(10)

			# Switch to Handstand Mode
			print("Switching to Handstand Mode...")
			await conn.datachannel.pub_sub.publish_request_new(
				RTC_TOPIC["SPORT_MOD"], 
				{
					"api_id": SPORT_CMD["StandOut"],
					"parameter": {"data": True}
				}
			)

			await asyncio.sleep(5)

			# Switch back to StandUp Mode
			print("Switching back to StandUp Mode...")
			await conn.datachannel.pub_sub.publish_request_new(
				RTC_TOPIC["SPORT_MOD"], 
				{
					"api_id": SPORT_CMD["StandOut"],
					"parameter": {"data": False}
				}
			)

			# await asyncio.sleep(5)
			# Perform a backflip
			# print(f"Performing BackFlip")
			# await conn.datachannel.pub_sub.publish_request_new(
			#     RTC_TOPIC["SPORT_MOD"], 
			#     {
			#         "api_id": SPORT_CMD["BackFlip"],
			#         "parameter": {"data": True}
			#     }
			# )

			# Keep the program running for a while
			await asyncio.sleep(3600)
		
		except ValueError as e:
			# Log any value errors that occur during the process.
			logging.error(f"An error occurred: {e}")

	if __name__ == "__main__":
		try:
			asyncio.run(main())
		except KeyboardInterrupt:
			# Handle Ctrl+C to exit gracefully.
			print("\nProgram interrupted by user")
			sys.exit(0)

	================
	File: examples/data_channel/sportmodestate/sportmodestate.py
	================
	import asyncio
	import logging
	import sys
	from go2_webrtc_driver.webrtc_driver import Go2WebRTCConnection, WebRTCConnectionMethod
	from go2_webrtc_driver.constants import RTC_TOPIC

	# Enable logging for debugging
	logging.basicConfig(level=logging.FATAL)

	def display_data(message):

		imu_state = message['imu_state']
		quaternion = imu_state['quaternion']
		gyroscope = imu_state['gyroscope']
		accelerometer = imu_state['accelerometer']
		rpy = imu_state['rpy']
		temperature = imu_state['temperature']

		mode = message['mode']
		progress = message['progress']
		gait_type = message['gait_type']
		foot_raise_height = message['foot_raise_height']
		position = message['position']
		body_height = message['body_height']
		velocity = message['velocity']
		yaw_speed = message['yaw_speed']
		range_obstacle = message['range_obstacle']
		foot_force = message['foot_force']
		foot_position_body = message['foot_position_body']
		foot_speed_body = message['foot_speed_body']

		# Clear the entire screen and reset cursor position to top
		sys.stdout.write("\033[H\033[J")

		# Print each piece of data on a separate line
		print("Go2 Robot Status")
		print("===================")
		print(f"Mode: {mode}")
		print(f"Progress: {progress}")
		print(f"Gait Type: {gait_type}")
		print(f"Foot Raise Height: {foot_raise_height} m")
		print(f"Position: {position}")
		print(f"Body Height: {body_height} m")
		print(f"Velocity: {velocity}")
		print(f"Yaw Speed: {yaw_speed}")
		print(f"Range Obstacle: {range_obstacle}")
		print(f"Foot Force: {foot_force}")
		print(f"Foot Position (Body): {foot_position_body}")
		print(f"Foot Speed (Body): {foot_speed_body}")
		print("-------------------")
		print(f"IMU - Quaternion: {quaternion}")
		print(f"IMU - Gyroscope: {gyroscope}")
		print(f"IMU - Accelerometer: {accelerometer}")
		print(f"IMU - RPY: {rpy}")
		print(f"IMU - Temperature: {temperature}Â°C")
		
		# Optionally, flush to ensure immediate output
		sys.stdout.flush()



	async def main():
		try:
			# Choose a connection method (uncomment the correct one)
			conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, ip="192.168.8.181")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, serialNumber="B42D2000XXXXXXXX")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.Remote, serialNumber="B42D2000XXXXXXXX", username="email@gmail.com", password="pass")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalAP)

			# Connect to the WebRTC service.
			await conn.connect()


			# Define a callback function to handle sportmode status when received.
			def sportmodestatus_callback(message):
				current_message = message['data']
				
				display_data(current_message)


			# Subscribe to the sportmode status data and use the callback function to process incoming messages.
			conn.datachannel.pub_sub.subscribe(RTC_TOPIC['LF_SPORT_MOD_STATE'], sportmodestatus_callback)


			# Keep the program running to allow event handling for 1 hour.
			await asyncio.sleep(3600)

		except ValueError as e:
			# Log any value errors that occur during the process.
			logging.error(f"An error occurred: {e}")


	if __name__ == "__main__":
		try:
			asyncio.run(main())
		except KeyboardInterrupt:
			# Handle Ctrl+C to exit gracefully.
			print("\nProgram interrupted by user")
			sys.exit(0)

	================
	File: examples/data_channel/vui/vui.py
	================
	import asyncio
	import logging
	import json
	import sys
	from go2_webrtc_driver.webrtc_driver import Go2WebRTCConnection, WebRTCConnectionMethod
	from go2_webrtc_driver.constants import RTC_TOPIC, VUI_COLOR

	# Enable logging for debugging
	logging.basicConfig(level=logging.FATAL)


	async def main():
		try:
			# Choose a connection method (uncomment the correct one)
			conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, ip="192.168.8.181")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, serialNumber="B42D2000XXXXXXXX")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.Remote, serialNumber="B42D2000XXXXXXXX", username="email@gmail.com", password="pass")
			# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalAP)

			# Connect to the WebRTC service.
			await conn.connect()

			############################
			####### FLASH LIGHT ########
			############################

			# Get the current brightness
			print("\nFetching the current brightness level...")
			response = await conn.datachannel.pub_sub.publish_request_new(
				RTC_TOPIC["VUI"], 
				{"api_id": 1006}
			)

			if response['data']['header']['status']['code'] == 0:
				data = json.loads(response['data']['data'])
				current_brightness = data['brightness']
				print(f"Current brightness level: {current_brightness}\n")

			# Adjusting brightness level from 0 to 10
			print("Increasing brightness from 0 to 10...")
			for brightness_level in range(0, 11):
				await conn.datachannel.pub_sub.publish_request_new(
					RTC_TOPIC["VUI"], 
					{
						"api_id": 1005,
						"parameter": {"brightness": brightness_level}
					}
				)
				print(f"Brightness level: {brightness_level}/10")
				await asyncio.sleep(0.5)

			# Adjusting brightness level from 10 back to 0
			print("\nDecreasing brightness from 10 to 0...")
			for brightness_level in range(10, -1, -1):
				await conn.datachannel.pub_sub.publish_request_new(
					RTC_TOPIC["VUI"], 
					{
						"api_id": 1005,
						"parameter": {"brightness": brightness_level}
					}
				)
				print(f"Brightness level: {brightness_level}/10")
				await asyncio.sleep(0.5)

			# Change the LED color to purple
			print("\nChanging LED color to purple for 5 seconds...")
			await conn.datachannel.pub_sub.publish_request_new(
				RTC_TOPIC["VUI"], 
				{
					"api_id": 1007,
					"parameter": 
					{
						"color": VUI_COLOR.PURPLE,
						"time": 5
					}
				}
			)
			await asyncio.sleep(6)

			# Change the LED color to cyan and flash
			# flash_cycle is between 499 and time*1000
			print("\nChanging LED color to cyan with flash (cycle: 1000ms)...")
			await conn.datachannel.pub_sub.publish_request_new(
				RTC_TOPIC["VUI"], 
				{
					"api_id": 1007,
					"parameter": 
					{
						"color": VUI_COLOR.CYAN,
						"time": 5,
						"flash_cycle": 1000  # Flash every second
					}
				}
			)
			await asyncio.sleep(5)

			############################
			####### VOLUME CONTROL ######
			############################

			# Get the current volume
			print("\nFetching the current volume level...")
			response = await conn.datachannel.pub_sub.publish_request_new(
				RTC_TOPIC["VUI"], 
				{"api_id": 1004}
			)

			if response['data']['header']['status']['code'] == 0:
				data = json.loads(response['data']['data'])
				current_volume = data['volume']
				print(f"Current volume level: {current_volume}/10\n")

			# Set Volume to 50%
			print("Setting volume to 50% (5/10)...")
			await conn.datachannel.pub_sub.publish_request_new(
				RTC_TOPIC["VUI"], 
				{
					"api_id": 1003,
					"parameter": {"volume": 5}
				}
			)

			# Keep the program running to allow event handling for 1 hour.
			await asyncio.sleep(3600)

		except ValueError as e:
			# Log any value errors that occur during the process.
			logging.error(f"An error occurred: {e}")


	if __name__ == "__main__":
		try:
			asyncio.run(main())
		except KeyboardInterrupt:
			# Handle Ctrl+C to exit gracefully.
			print("\nProgram interrupted by user")
			sys.exit(0)

	================
	File: examples/video/camera_stream/display_video_channel.py
	================
	import cv2
	import numpy as np

	# Create an OpenCV window and display a blank image
	height, width = 720, 1280  # Adjust the size as needed
	img = np.zeros((height, width, 3), dtype=np.uint8)
	cv2.imshow('Video', img)
	cv2.waitKey(1)  # Ensure the window is created

	import asyncio
	import logging
	import threading
	import time
	from queue import Queue
	from go2_webrtc_driver.webrtc_driver import Go2WebRTCConnection, WebRTCConnectionMethod
	from aiortc import MediaStreamTrack

	# Enable logging for debugging
	logging.basicConfig(level=logging.FATAL)

	def main():
		frame_queue = Queue()

		# Choose a connection method (uncomment the correct one)
		conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, ip="192.168.8.181")
		# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, serialNumber="B42D2000XXXXXXXX")
		# conn = Go2WebRTCConnection(WebRTCConnectionMethod.Remote, serialNumber="B42D2000XXXXXXXX", username="email@gmail.com", password="pass")
		# conn = Go2WebRTCConnection(WebRTCConnectionMethod.LocalAP)

		# Async function to receive video frames and put them in the queue
		async def recv_camera_stream(track: MediaStreamTrack):
			while True:
				frame = await track.recv()
				# Convert the frame to a NumPy array
				img = frame.to_ndarray(format="bgr24")
				frame_queue.put(img)

		def run_asyncio_loop(loop):
			asyncio.set_event_loop(loop)
			async def setup():
				try:
					# Connect to the device
					await conn.connect()

					# Switch video channel on and start receiving video frames
					conn.video.switchVideoChannel(True)

					# Add callback to handle received video frames
					conn.video.add_track_callback(recv_camera_stream)
				except Exception as e:
					logging.error(f"Error in WebRTC connection: {e}")

			# Run the setup coroutine and then start the event loop
			loop.run_until_complete(setup())
			loop.run_forever()

		# Create a new event loop for the asyncio code
		loop = asyncio.new_event_loop()

		# Start the asyncio event loop in a separate thread
		asyncio_thread = threading.Thread(target=run_asyncio_loop, args=(loop,))
		asyncio_thread.start()

		try:
			while True:
				if not frame_queue.empty():
					img = frame_queue.get()
					print(f"Shape: {img.shape}, Dimensions: {img.ndim}, Type: {img.dtype}, Size: {img.size}")
					# Display the frame
					cv2.imshow('Video', img)
					if cv2.waitKey(1) & 0xFF == ord('q'):
						break
				else:
					# Sleep briefly to prevent high CPU usage
					time.sleep(0.01)
		finally:
			cv2.destroyAllWindows()
			# Stop the asyncio event loop
			loop.call_soon_threadsafe(loop.stop)
			asyncio_thread.join()

	if __name__ == "__main__":
		main()

	================
	File: go2_webrtc_driver/__init__.py
	================
	import sys
	import os

	# Get the absolute path of the 'go2_webrtc_driver' directory
	current_dir = os.path.dirname(os.path.abspath(__file__))

	# Build absolute path to 'libs' directory
	libs_path = os.path.abspath(os.path.join(current_dir, '..', 'libs'))

	# Add aiortc and aioice directories to sys.path
	# sys.path.insert(0, os.path.join(libs_path, 'aiortc', 'src'))
	sys.path.insert(0, os.path.join(libs_path, 'aioice', 'src'))

	================
	File: go2_webrtc_driver/constants.py
	================
	from enum import Enum

	DATA_CHANNEL_TYPE = {
		"VALIDATION": "validation",
		"SUBSCRIBE": "subscribe",
		"UNSUBSCRIBE": "unsubscribe",
		"MSG": "msg",
		"REQUEST": "req",
		"RESPONSE": "res",
		"VID": "vid",
		"AUD": "aud",
		"ERR": "err",
		"HEARTBEAT": "heartbeat",
		"RTC_INNER_REQ": "rtc_inner_req",
		"RTC_REPORT": "rtc_report",
		"ADD_ERROR": "add_error",
		"RM_ERROR": "rm_error",
		"ERRORS": "errors",
	}

	class WebRTCConnectionMethod(Enum):
		LocalAP = 1
		LocalSTA = 2
		Remote = 3

	app_error_messages = {
		"app_error_code_100_1": "DDS message timeout",
		"app_error_code_100_10": "Battery communication error",
		"app_error_code_100_2": "Distribution switch abnormal",
		"app_error_code_100_20": "Abnormal mote control communication",
		"app_error_code_100_40": "MCU communication error",
		"app_error_code_100_80": "Motor communication error",
		"app_error_code_200_1": "Rear left fan jammed",
		"app_error_code_200_2": "Rear right fan jammed",
		"app_error_code_200_4": "Front fan jammed",
		"app_error_code_300_1": "Overcurrent",
		"app_error_code_300_10": "Winding overheating",
		"app_error_code_300_100": "Motor communication interruption",
		"app_error_code_300_2": "Overvoltage",
		"app_error_code_300_20": "Encoder abnormal",
		"app_error_code_300_4": "Driver overheating",
		"app_error_code_300_8": "Generatrix undervoltage",
		"app_error_code_400_1": "Motor rotate speed abnormal",
		"app_error_code_400_10": "Abnormal dirt index",
		"app_error_code_400_2": "PointCloud data abnormal",
		"app_error_code_400_4": "Serial port data abnormal",
		"app_error_code_500_1": "UWB serial port open abnormal",
		"app_error_code_500_2": "Robot dog information retrieval abnormal",
		"app_error_code_600_4": "Overheating software protection",
		"app_error_code_600_8": "Low battery software protection",
		"app_error_source_100": "Communication firmware malfunction",
		"app_error_source_200": "Communication firmware malfunction",
		"app_error_source_300": "Motor malfunction",
		"app_error_source_400": "Radar malfunction",
		"app_error_source_500": "UWB malfunction",
		"app_error_source_600": "Motion Control",
		"app_error_wheel_300_100": "Motor Communication Interruption",
		"app_error_wheel_300_40": "Calibration Data Abnormality",
		"app_error_wheel_300_80": "Abnormal Reset"
	}

	RTC_TOPIC = {
		"LOW_STATE": "rt/lf/lowstate",
		"MULTIPLE_STATE": "rt/multiplestate",
		"FRONT_PHOTO_REQ": "rt/api/videohub/request",
		"ULIDAR_SWITCH": "rt/utlidar/switch",
		"ULIDAR": "rt/utlidar/voxel_map",
		"ULIDAR_ARRAY": "rt/utlidar/voxel_map_compressed",
		"ULIDAR_STATE": "rt/utlidar/lidar_state",
		"ROBOTODOM": "rt/utlidar/robot_pose",
		"UWB_REQ": "rt/api/uwbswitch/request",
		"UWB_STATE": "rt/uwbstate",
		"LOW_CMD": "rt/lowcmd",
		"WIRELESS_CONTROLLER": "rt/wirelesscontroller",
		"SPORT_MOD": "rt/api/sport/request",
		"SPORT_MOD_STATE": "rt/sportmodestate",
		"LF_SPORT_MOD_STATE": "rt/lf/sportmodestate",
		"BASH_REQ": "rt/api/bashrunner/request",
		"SELF_TEST": "rt/selftest",
		"GRID_MAP": "rt/mapping/grid_map",
		"SERVICE_STATE": "rt/servicestate",
		"GPT_FEEDBACK": "rt/gptflowfeedback",
		"VUI": "rt/api/vui/request",
		"OBSTACLES_AVOID": "rt/api/obstacles_avoid/request",
		"SLAM_QT_COMMAND": "rt/qt_command",
		"SLAM_ADD_NODE": "rt/qt_add_node",
		"SLAM_ADD_EDGE": "rt/qt_add_edge",
		"SLAM_QT_NOTICE": "rt/qt_notice",
		"SLAM_PC_TO_IMAGE_LOCAL": "rt/pctoimage_local",
		"SLAM_ODOMETRY": "rt/lio_sam_ros2/mapping/odometry",
		"ARM_COMMAND": "rt/arm_Command",
		"ARM_FEEDBACK": "rt/arm_Feedback",
		"AUDIO_HUB_REQ": "rt/api/audiohub/request",
		"AUDIO_HUB_PLAY_STATE": "rt/audiohub/player/state",
		"GAS_SENSOR": "rt/gas_sensor",
		"GAS_SENSOR_REQ": "rt/api/gas_sensor/request",
		"LIDAR_MAPPING_CMD": "rt/uslam/client_command",
		"LIDAR_MAPPING_CLOUD_POINT": "rt/uslam/frontend/cloud_world_ds",
		"LIDAR_MAPPING_ODOM": "rt/uslam/frontend/odom",
		"LIDAR_MAPPING_PCD_FILE": "rt/uslam/cloud_map",
		"LIDAR_MAPPING_SERVER_LOG": "rt/uslam/server_log",
		"LIDAR_LOCALIZATION_ODOM": "rt/uslam/localization/odom",
		"LIDAR_NAVIGATION_GLOBAL_PATH": "rt/uslam/navigation/global_path",
		"LIDAR_LOCALIZATION_CLOUD_POINT": "rt/uslam/localization/cloud_world",
		"PROGRAMMING_ACTUATOR_CMD": "rt/programming_actuator/command",
		"ASSISTANT_RECORDER": "rt/api/assistant_recorder/request",
		"MOTION_SWITCHER": "rt/api/motion_switcher/request"
	}

	SPORT_CMD = {
		"Damp": 1001,
		"BalanceStand": 1002,
		"StopMove": 1003,
		"StandUp": 1004,
		"StandDown": 1005,
		"RecoveryStand": 1006,
		"Euler": 1007,
		"Move": 1008,
		"Sit": 1009,
		"RiseSit": 1010,
		"SwitchGait": 1011,
		"Trigger": 1012,
		"BodyHeight": 1013,
		"FootRaiseHeight": 1014,
		"SpeedLevel": 1015,
		"Hello": 1016,
		"Stretch": 1017,
		"TrajectoryFollow": 1018,
		"ContinuousGait": 1019,
		"Content": 1020,
		"Wallow": 1021,
		"Dance1": 1022,
		"Dance2": 1023,
		"GetBodyHeight": 1024,
		"GetFootRaiseHeight": 1025,
		"GetSpeedLevel": 1026,
		"SwitchJoystick": 1027,
		"Pose": 1028,
		"Scrape": 1029,
		"FrontFlip": 1030,
		"LeftFlip": 1042,
		"RightFlip": 1043,
		"BackFlip": 1044,
		"FrontJump": 1031,
		"FrontPounce": 1032,
		"WiggleHips": 1033,
		"GetState": 1034,
		"EconomicGait": 1035,
		"LeadFollow": 1045,
		"FingerHeart": 1036,
		"Bound": 1304,
		"MoonWalk": 1305,
		"OnesidedStep": 1303,
		"CrossStep": 1302,
		"Handstand": 1301,
		"StandOut": 1039,
		"FreeWalk": 1045,
		"Standup": 1050,
		"CrossWalk": 1051
	}

	class VUI_COLOR:
		WHITE: str = 'white'
		RED: str = 'red'
		YELLOW: str = 'yellow'
		BLUE: str = 'blue'
		GREEN: str = 'green'
		CYAN: str = 'cyan'
		PURPLE: str = 'purple'

	# Audio API IDs
	AUDIO_API = {
		# Audio Player Commands
		"GET_AUDIO_LIST": 1001,
		"SELECT_START_PLAY": 1002,
		"PAUSE": 1003,
		"UNSUSPEND": 1004,
		"SELECT_PREV_START_PLAY": 1005,
		"SELECT_NEXT_START_PLAY": 1006,
		"SET_PLAY_MODE": 1007,
		"SELECT_RENAME": 1008,
		"SELECT_DELETE": 1009,
		"GET_PLAY_MODE": 1010,
		
		# Audio Upload
		"UPLOAD_AUDIO_FILE": 2001,
		
		# Internal Corpus
		"PLAY_START_OBSTACLE_AVOIDANCE": 3001,
		"PLAY_EXIT_OBSTACLE_AVOIDANCE": 3002,
		"PLAY_START_COMPANION_MODE": 3003,
		"PLAY_EXIT_COMPANION_MODE": 3004,
		
		# Megaphone
		"ENTER_MEGAPHONE": 4001,
		"EXIT_MEGAPHONE": 4002,
		"UPLOAD_MEGAPHONE": 4003,
		
		# Internal Long Corpus
		"INTERNAL_LONG_CORPUS_SELECT_TO_PLAY": 5001,
		"INTERNAL_LONG_CORPUS_PLAYBACK_COMPLETED": 5002,
		"INTERNAL_LONG_CORPUS_STOP_PLAYING": 5003
	}

	================
	File: go2_webrtc_driver/encryption.py
	================
	from Crypto.Cipher import AES
	from Crypto.PublicKey import RSA
	from Crypto.Cipher import PKCS1_v1_5
	import base64
	import uuid
	import binascii

	###############
	### AES handling
	###############

	# Function to generate a UUID and return it as a 32-character hexadecimal string
	def _generate_uuid() -> str:
		uuid_32 = uuid.uuid4().bytes  
		uuid_32_hex_string = binascii.hexlify(uuid_32).decode('utf-8')
		return uuid_32_hex_string

	def pad(data: str) -> bytes:
		"""Pad data to be a multiple of 16 bytes (AES block size)."""
		block_size = AES.block_size
		padding = block_size - len(data) % block_size
		padded_data = data + chr(padding) * padding
		return padded_data.encode('utf-8')

	def unpad(data: bytes) -> str:
		"""Remove padding from data."""
		padding = data[-1]
		return data[:-padding].decode('utf-8')

	def aes_encrypt(data: str, key: str) -> str:
		"""Encrypt the given data using AES (ECB mode with PKCS5 padding)."""
		# Ensure key is 32 bytes for AES-256
		key_bytes = key.encode('utf-8')

		# Pad the data to ensure it is a multiple of block size
		padded_data = pad(data)

		# Create AES cipher in ECB mode
		cipher = AES.new(key_bytes, AES.MODE_ECB)

		# Encrypt data
		encrypted_data = cipher.encrypt(padded_data)

		# Encode encrypted data to Base64
		encoded_encrypted_data = base64.b64encode(encrypted_data).decode('utf-8')

		return encoded_encrypted_data

	def aes_decrypt(encrypted_data: str, key: str) -> str:
		"""Decrypt the given data using AES (ECB mode with PKCS5 padding)."""
		# Ensure key is 32 bytes for AES-256
		key_bytes = key.encode('utf-8')

		# Decode Base64 encrypted data
		encrypted_data_bytes = base64.b64decode(encrypted_data)

		# Create AES cipher in ECB mode
		cipher = AES.new(key_bytes, AES.MODE_ECB)

		# Decrypt data
		decrypted_padded_data = cipher.decrypt(encrypted_data_bytes)

		# Unpad the decrypted data
		decrypted_data = unpad(decrypted_padded_data)

		return decrypted_data

	# Function to generate an AES key
	def generate_aes_key() -> str:
		return _generate_uuid()

	###############
	### RSA handling
	###############

	def rsa_load_public_key(pem_data: str) -> RSA.RsaKey:
		"""Load an RSA public key from a PEM-formatted string."""
		key_bytes = base64.b64decode(pem_data)
		return RSA.import_key(key_bytes)

	def rsa_encrypt(data: str, public_key: RSA.RsaKey) -> str:
		"""Encrypt data using RSA and a given public key."""
		cipher = PKCS1_v1_5.new(public_key)

		# Maximum chunk size for encryption with RSA/ECB/PKCS1Padding is key size - 11 bytes
		max_chunk_size = public_key.size_in_bytes() - 11
		data_bytes = data.encode('utf-8')

		encrypted_bytes = bytearray()
		for i in range(0, len(data_bytes), max_chunk_size):
			chunk = data_bytes[i:i + max_chunk_size]
			encrypted_chunk = cipher.encrypt(chunk)
			encrypted_bytes.extend(encrypted_chunk)

		# Base64 encode the final encrypted data
		encoded_encrypted_data = base64.b64encode(encrypted_bytes).decode('utf-8')
		return encoded_encrypted_data

	# Example usage
	if __name__ == "__main__":
		# Public key
		public_key_pem = """
		MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnOc1sgpzL4GTVp9/oQ0H
		D7eeAO2GJUABfjX3TitgXiXN1Ktn2WLsLrtAiIuj3OrrRogx8fCT16oxnXx/Xrap
		BRHD/ufHZ08A2IRVw6U6vKDv8TpQH22sAEtUji4/P2AaZmeOxFsYW5FshQr37KBG
		+cBb7rJWLWEJpIXmCpnt37GGCtsACqRegkl7qQ8Q0OiJmtrYLPi00xSstZb+Wv1v
		8B0eTY3POAUXjgl357L5dc6vS99rYFkYeUCTWHaH4d51Z/KgCRYUadboDc2cgNg/
		z2dbO9S3HADegbIsN3fTbjDCruKfvc5ejxlFZ0Xbu6SScQbmkP8t3TPvy/DXGJAh
		NwIDAQAB
		"""

		# Example value of UUID or data you wish to encrypt
		value_of = "26a663562a6f4dfbbbbf2b50c1a278cb"

		# Load public key
		public_key = rsa_load_public_key(public_key_pem)

		# Encrypt the message
		encrypted_value = rsa_encrypt(value_of, public_key)
		print(f"Encrypted Value: {encrypted_value}")

		# AES testing
		aes_key = "26a663562a6f4dfbbbbf2b50c1a278cb"  # Example 32-character UUID

		# Encrypt a message with AES
		encrypted_message = aes_encrypt("Hello, world!", aes_key)
		print(f"Encrypted AES Message: {encrypted_message}")

		# Decrypt the AES message
		decrypted_message = aes_decrypt(encrypted_message, aes_key)
		print(f"Decrypted AES Message: {decrypted_message}")

	================
	File: go2_webrtc_driver/lidar/lidar_decoder_points.py
	================
	# Redistribution and use in source and binary forms, with or without
	# modification, are permitted provided that the following conditions are met:
	#
	# 1. Redistributions of source code must retain the above copyright notice, this
	#    list of conditions and the following disclaimer.
	#
	# 2. Redistributions in binary form must reproduce the above copyright notice,
	#    this list of conditions and the following disclaimer in the documentation
	#    and/or other materials provided with the distribution.
	#
	# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
	# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
	# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
	# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
	# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

	import numpy as np
	import lz4.block

	def decompress(compressed_data, decomp_size):
		decompressed = lz4.block.decompress(
			compressed_data,
			uncompressed_size=decomp_size
		)
		return decompressed

	def bits_to_points(buf, origin, resolution=0.05):
		buf = np.frombuffer(bytearray(buf), dtype=np.uint8)
		nonzero_indices = np.nonzero(buf)[0]
		points = []

		for n in nonzero_indices:
			byte_value = buf[n]
			z = n // 0x800
			n_slice = n % 0x800
			y = n_slice // 0x10
			x_base = (n_slice % 0x10) * 8

			for bit_pos in range(8):
				if byte_value & (1 << (7 - bit_pos)):
					x = x_base + bit_pos
					points.append((x,y,z))

		return np.array(points) * resolution + origin

	class LidarDecoder:
		def decode(self, compressed_data, data):
			def points():
				decompressed = decompress(compressed_data, data["src_size"])
				points = bits_to_points(decompressed, data["origin"], data["resolution"])
				return points

			return {
					"points": points,
					"raw": compressed_data,
			}

	================
	File: go2_webrtc_driver/lidar/lidar_decoder.py
	================
	# Redistribution and use in source and binary forms, with or without
	# modification, are permitted provided that the following conditions are met:
	#
	# 1. Redistributions of source code must retain the above copyright notice, this
	#    list of conditions and the following disclaimer.
	#
	# 2. Redistributions in binary form must reproduce the above copyright notice,
	#    this list of conditions and the following disclaimer in the documentation
	#    and/or other materials provided with the distribution.
	#
	# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
	# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
	# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
	# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
	# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

	import math
	import ctypes
	import numpy as np
	import os

	from wasmtime import Config, Engine, Store, Module, Instance, Func, FuncType
	from wasmtime import ValType


	class LidarDecoder:
		def __init__(self) -> None:

			config = Config()
			config.wasm_multi_value = True
			config.debug_info = True
			self.store = Store(Engine(config))

			wasm_path = os.path.join(os.path.dirname(__file__), "libvoxel.wasm")
			self.module = Module.from_file(self.store.engine, wasm_path)

			self.a_callback_type = FuncType([ValType.i32()], [ValType.i32()])
			self.b_callback_type = FuncType([ValType.i32(), ValType.i32(), ValType.i32()], [])

			a = Func(self.store, self.a_callback_type, self.adjust_memory_size)
			b = Func(self.store, self.b_callback_type, self.copy_memory_region)

			self.instance = Instance(self.store, self.module, [a, b])

			self.generate = self.instance.exports(self.store)["e"]
			self.malloc = self.instance.exports(self.store)["f"]
			self.free = self.instance.exports(self.store)["g"]
			self.wasm_memory = self.instance.exports(self.store)["c"]

			self.buffer = self.wasm_memory.data_ptr(self.store)
			self.memory_size = self.wasm_memory.data_len(self.store)

			self.buffer_ptr = int.from_bytes(self.buffer, "little")

			self.HEAP8 = (ctypes.c_int8 * self.memory_size).from_address(self.buffer_ptr)
			self.HEAP16 = (ctypes.c_int16 * (self.memory_size // 2)).from_address(self.buffer_ptr)
			self.HEAP32 = (ctypes.c_int32 * (self.memory_size // 4)).from_address(self.buffer_ptr)
			self.HEAPU8 = (ctypes.c_uint8 * self.memory_size).from_address(self.buffer_ptr)
			self.HEAPU16 = (ctypes.c_uint16 * (self.memory_size // 2)).from_address(self.buffer_ptr)
			self.HEAPU32 = (ctypes.c_uint32 * (self.memory_size // 4)).from_address(self.buffer_ptr)
			self.HEAPF32 = (ctypes.c_float * (self.memory_size // 4)).from_address(self.buffer_ptr)
			self.HEAPF64 = (ctypes.c_double * (self.memory_size // 8)).from_address(self.buffer_ptr)

			self.input = self.malloc(self.store, 61440)
			self.decompressBuffer = self.malloc(self.store, 80000)
			self.positions = self.malloc(self.store, 2880000)
			self.uvs = self.malloc(self.store, 1920000)
			self.indices = self.malloc(self.store, 5760000)
			self.decompressedSize = self.malloc(self.store, 4)
			self.faceCount = self.malloc(self.store, 4)
			self.pointCount = self.malloc(self.store, 4)
			self.decompressBufferSize = 80000

		def adjust_memory_size(self, t):
			return len(self.HEAPU8)

		def copy_within(self, target, start, end):
			# Copy the sublist for the specified range [start:end]
			sublist = self.HEAPU8[start:end]

			# Replace elements in the list starting from index 'target'
			for i in range(len(sublist)):
				if target + i < len(self.HEAPU8):
					self.HEAPU8[target + i] = sublist[i]
		
		def copy_memory_region(self, t, n, a):
			self.copy_within(t, n, n + a)

		def get_value(self, t, n="i8"):
			if n.endswith("*"):
				n = "*"
			if n == "i1" or n == "i8":
				return self.HEAP8[t]
			elif n == "i16":
				return self.HEAP16[t >> 1]
			elif n == "i32" or n == "i64":
				return self.HEAP32[t >> 2]
			elif n == "float":
				return self.HEAPF32[t >> 2]
			elif n == "double":
				return self.HEAPF64[t >> 3]
			elif n == "*":
				return self.HEAPU32[t >> 2]
			else:
				raise ValueError(f"invalid type for getValue: {n}")
			
		def add_value_arr(self, start, value):
			if start + len(value) <= len(self.HEAPU8):
				for i, byte in enumerate(value):
					self.HEAPU8[start + i] = byte
			else:
				raise ValueError("Not enough space to insert bytes at the specified index.")

		def decode(self, compressed_data, data):
			self.add_value_arr(self.input, compressed_data)

			some_v = math.floor(data["origin"][2] / data["resolution"])

			self.generate(
				self.store,
				self.input,
				len(compressed_data),
				self.decompressBufferSize,
				self.decompressBuffer,
				self.decompressedSize, 
				self.positions,
				self.uvs,
				self.indices,          
				self.faceCount,
				self.pointCount,        
				some_v
			)

			self.get_value(self.decompressedSize, "i32")
			c = self.get_value(self.pointCount, "i32")
			u = self.get_value(self.faceCount, "i32")

			positions_slice = self.HEAPU8[self.positions:self.positions + u * 12]
			positions_copy = bytearray(positions_slice)
			p = np.frombuffer(positions_copy, dtype=np.uint8)

			uvs_slice = self.HEAPU8[self.uvs:self.uvs + u * 8]
			uvs_copy = bytearray(uvs_slice)
			r = np.frombuffer(uvs_copy, dtype=np.uint8)

			indices_slice = self.HEAPU8[self.indices:self.indices + u * 24]
			indices_copy = bytearray(indices_slice)
			o = np.frombuffer(indices_copy, dtype=np.uint32)

			return {
				"point_count": c,
				"face_count": u,
				"positions": p,
				"uvs": r,
				"indices": o
			}

	================
	File: go2_webrtc_driver/msgs/error_handler.py
	================
	from ..constants import app_error_messages
	import time

	def integer_to_hex_string(error_code):
		"""
		Converts an integer error code to a hexadecimal string.
		
		Args:
			error_code (int): The error code as an integer.
			
		Returns:
			str: The error code as a hexadecimal string, without the '0x' prefix, in uppercase.
		"""
		if not isinstance(error_code, int):
			raise ValueError("Input must be an integer.")

		# Convert the integer to a hex string and remove the '0x' prefix
		hex_string = hex(error_code)[2:].upper()

		return hex_string

	def get_error_code_text(error_source, error_code):
		"""
		Retrieve the error message based on the error source and error code.

		Args:
			error_code_dict (dict): Dictionary mapping error codes to messages.
			error_source (int): The error source code (e.g., 100, 200, etc.).
			error_code (str): The specific error code in string form (e.g., "01", "10").

		Returns:
			str: The corresponding error message, or the fallback format.
		"""
		# Generate the key for looking up the error message
		key = f"app_error_code_{error_source}_{error_code}"
		
		# Check if the key exists in the error_code_dict
		if key in app_error_messages:
			return app_error_messages[key]
		else:
			# Fallback: return the combination of error_source and error_code
			return f"{error_source}-{error_code}"

	def get_error_source_text(error_source):
		"""
		Retrieve the error message based on the error source and error code.

		Args:
			error_code_dict (dict): Dictionary mapping error codes to messages.
			error_source (int): The error source code (e.g., 100, 200, etc.).
			error_code (str): The specific error code in string form (e.g., "01", "10").

		Returns:
			str: The corresponding error message, or the fallback format.
		"""
		# Generate the key for looking up the error message
		key = f"app_error_source_{error_source}"
		
		# Check if the key exists in the error_code_dict
		if key in app_error_messages:
			return app_error_messages[key]
		else:
			# Fallback: return the combination of error_source and error_code
			return f"{error_source}"

	def handle_error(message):
		"""
		Handle the error message, print the time, error source, and error message.

		Args:
			message (dict): The error message containing the data field.
		"""
		data = message["data"]

		for error in data:
			timestamp, error_source, error_code_int = error
			
			# Convert the timestamp to human-readable format
			readable_time = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(timestamp))

			error_source_text = get_error_source_text(error_source)
			
			# Convert the error code to a hexadecimal string
			error_code_hex = integer_to_hex_string(error_code_int)
			
			# Get the error message
			error_code_text = get_error_code_text(error_source, error_code_hex)

			print(f"\nðŸš¨ Error Received from Go2:\n"
				f"ðŸ•’ Time:          {readable_time}\n"
				f"ðŸ”¢ Error Source:  {error_source_text}\n"
				f"â— Error Code:    {error_code_text}\n")

	================
	File: go2_webrtc_driver/msgs/future_resolver.py
	================
	import logging
	from ..constants import DATA_CHANNEL_TYPE
	from ..util import get_nested_field

	class FutureResolver:
		def __init__(self):
			self.pending_responses = {}
			self.pending_callbacks = {}
			self.chunk_data_storage = {}

		def save_resolve(self, message_type, topic, future, identifier):
			key = self.generate_message_key(message_type,topic,identifier)
			if key in self.pending_callbacks:
				self.pending_callbacks[key].append(future)
			else:
				self.pending_callbacks[key] = [future]

		def run_resolve_for_topic(self, message):
			if not message.get("type"):
				return

			if message["type"] == DATA_CHANNEL_TYPE["RTC_INNER_REQ"] and get_nested_field(message, "info", "req_type") == "request_static_file":
				self.run_resolve_for_topic_for_file(message)
				return

			key = self.generate_message_key(
				message["type"],
				message.get("topic", ""),
				get_nested_field(message, "data", "uuid") or
				get_nested_field(message, "data", "header", "identity", "id") or
				get_nested_field(message, "info", "uuid") or
				get_nested_field(message, "info", "req_uuid")
			)

			content_info = get_nested_field(message, "data", "content_info")
			if content_info and content_info.get("enable_chunking"):
				chunk_index = content_info.get("chunk_index")
				total_chunks = content_info.get("total_chunk_num")

				if total_chunks is None or total_chunks == 0:
					raise ValueError("Total number of chunks cannot be zero")
				if chunk_index is None:
					raise ValueError("Chunk index is missing")

				data_chunk = message["data"].get("data")
				if chunk_index < total_chunks:
					if key in self.chunk_data_storage:
						self.chunk_data_storage[key].append(data_chunk)
					else:
						self.chunk_data_storage[key] = [data_chunk]
					return
				else:
					self.chunk_data_storage[key].append(data_chunk)
					message["data"]["data"] = self.merge_array_buffers(self.chunk_data_storage[key])
					del self.chunk_data_storage[key]

			# Resolve the pending future with the final message
			if key in self.pending_callbacks:
				for future in self.pending_callbacks[key]:
					if future:
						future.set_result(message)  # Resolve the future with the message
				del self.pending_callbacks[key]

		def merge_array_buffers(self, buffers):
			total_length = sum(len(buf) for buf in buffers)
			merged_buffer = bytearray(total_length)

			current_position = 0
			for buffer in buffers:
				merged_buffer[current_position:current_position + len(buffer)] = buffer
				current_position += len(buffer)

			return bytes(merged_buffer)

		def run_resolve_for_topic_for_file(self, message):
			key = self.generate_message_key(
				message["type"], 
				message.get("topic", ""), 
				get_nested_field(message, "data", "uuid") or
				get_nested_field(message, "data", "header", "identity", "id") or
				get_nested_field(message, "info", "uuid") or
				get_nested_field(message, "info", "req_uuid")
			)

			file_info = get_nested_field(message, "info", "file")
			if file_info and file_info.get("enable_chunking"):
				chunk_index = file_info.get("chunk_index")
				total_chunks = file_info.get("total_chunk_num")

				if total_chunks is None or total_chunks == 0:
					raise ValueError("Total number of chunks cannot be zero")
				if chunk_index is None:
					raise ValueError("Chunk index is missing")

				# Extract the chunk data
				data_chunk = file_info.get("data")

				# Initialize the key in chunk_data_storage if it doesn't exist
				if key not in self.chunk_data_storage:
					self.chunk_data_storage[key] = []

				# Append the chunk to the storage, ensuring it's in bytes
				self.chunk_data_storage[key].append(data_chunk.encode('utf-8') if isinstance(data_chunk, str) else data_chunk)

				# If this is the last chunk, combine all chunks and store the complete data
				if chunk_index == total_chunks:
					message["info"]["file"]["data"] = b''.join(self.chunk_data_storage[key])
					del self.chunk_data_storage[key]  # Clean up the storage

			# Resolve the pending future with the final message
			if key in self.pending_callbacks:
				for future in self.pending_callbacks[key]:
					if future:
						future.set_result(message)  # Resolve the future with the message
				del self.pending_callbacks[key]

		def generate_message_key(self, message_type, topic, identifier):
			return identifier or f"{message_type} $ {topic}"

	================
	File: go2_webrtc_driver/msgs/heartbeat.py
	================
	import asyncio
	import logging
	import time
	from ..constants import DATA_CHANNEL_TYPE

	class WebRTCDataChannelHeartBeat:
		def __init__(self, channel, pub_sub):
			self.channel = channel
			self.heartbeat_timer = None
			self.heartbeat_response = None
			self.publish = pub_sub.publish_without_callback

		def _format_date(self, timestamp):
			return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(timestamp))

		def start_heartbeat(self):
			"""Start sending heartbeat messages every 2 seconds."""
			self.heartbeat_timer = asyncio.get_event_loop().call_later(2, self.send_heartbeat)

		def stop_heartbeat(self):
			"""Stop the heartbeat."""
			if self.heartbeat_timer:
				self.heartbeat_timer.cancel()
				self.heartbeat_timer = None

		def send_heartbeat(self):
			"""Send a heartbeat message."""
			if self.channel.readyState == "open":
				current_time = time.time()
				formatted_time = self._format_date(current_time)
				data = {
					"timeInStr": formatted_time,
					"timeInNum": int(current_time)
				}
				self.publish(
					"",
					data,
					DATA_CHANNEL_TYPE["HEARTBEAT"],
				)
			# Schedule the next heartbeat
			self.heartbeat_timer = asyncio.get_event_loop().call_later(2, self.send_heartbeat)

		def handle_response(self, message):
			"""Handle a received heartbeat message."""
			self.heartbeat_response = time.time()
			logging.info("Heartbeat response received.")

	================
	File: go2_webrtc_driver/msgs/pub_sub.py
	================
	import asyncio
	import json
	import time
	import random
	import logging
	from ..constants import DATA_CHANNEL_TYPE
	from .future_resolver import FutureResolver
	from ..util import get_nested_field

	class WebRTCDataChannelPubSub:

		def __init__(self, channel):
			self.channel = channel

			self.future_resolver = FutureResolver()
			self.subscriptions = {}  # Dictionary to hold callbacks keyed by topic
		
		def run_resolve(self, message):
			self.future_resolver.run_resolve_for_topic(message)

			 # Extract the topic from the message
			topic = message.get("topic")
			if topic in self.subscriptions:
				# Call the registered callback with the message
				callback = self.subscriptions[topic]
				callback(message)
			

		async def publish(self, topic, data=None, msg_type=None):
			channel = self.channel
			future = asyncio.get_event_loop().create_future()

			if channel.readyState == "open":
				message_dict = {
					"type": msg_type or DATA_CHANNEL_TYPE["MSG"],
					"topic": topic
				}
				# Only include "data" if it's not None
				if data is not None:
					message_dict["data"] = data
				
				# Convert the dictionary to a JSON string
				message = json.dumps(message_dict)

				channel.send(message)

				# Log the message being published
				logging.info(f"> message sent: {message}")

				# Store the future so it can be completed when the response is received
				uuid = (
					get_nested_field(data, "uuid") or
					get_nested_field(data, "header", "identity", "id") or 
					get_nested_field(data, "req_uuid")
				)

				self.future_resolver.save_resolve(msg_type or DATA_CHANNEL_TYPE["MSG"], topic, future, uuid)
			else:
				future.set_exception(Exception("Data channel is not open"))

			return await future
		

		def publish_without_callback(self, topic, data=None, msg_type=None):

			if self.channel.readyState == "open":
				message_dict = {
					"type": msg_type or DATA_CHANNEL_TYPE["MSG"],
					"topic": topic
				}

				# Only include "data" if it's not None
				if data is not None:
					message_dict["data"] = data
				
				# Convert the dictionary to a JSON string
				message = json.dumps(message_dict)
					
				self.channel.send(message)

				# Log the message being published
				logging.info(f"> message sent: {message}")
			else:
				Exception("Data channel is not open")
			

		async def publish_request_new(self, topic, options=None):
			# Generate a unique identifier
			generated_id = int(time.time() * 1000) % 2147483648 + random.randint(0, 1000)
			
			# Check if api_id is provided
			if not (options and "api_id" in options):
				print("Error: Please provide app id")
				return asyncio.Future().set_exception(Exception("Please provide app id"))

			# Build the request header and parameter
			request_payload = {
				"header": {
					"identity": {
						"id": options.get("id", generated_id),
						"api_id": options.get("api_id", 0)
					}
				},
				"parameter": ""
			}

			# Add data to parameter
			if options and "parameter" in options:
				request_payload["parameter"] = options["parameter"] if isinstance(options["parameter"], str) else json.dumps(options["parameter"])

			# Add priority if specified
			if options and "priority" in options:
				request_payload["header"]["policy"] = {
					"priority": 1
				}

			# Publish the request
			return await self.publish(topic, request_payload, DATA_CHANNEL_TYPE["REQUEST"])
		
		def subscribe(self, topic, callback=None):
			channel = self.channel

			if not channel or channel.readyState != "open":
				print("Error: Data channel is not open")
				return
			
			# Register the callback for the topic
			if callback:
				self.subscriptions[topic] = callback

			self.publish_without_callback(topic=topic, msg_type=DATA_CHANNEL_TYPE["SUBSCRIBE"])

		def unsubscribe(self, topic):
			channel = self.channel

			if not channel or channel.readyState != "open":
				print("Error: Data channel is not open")
				return

			self.publish_without_callback(topic=topic, msg_type=DATA_CHANNEL_TYPE["UNSUBSCRIBE"])

	================
	File: go2_webrtc_driver/msgs/rtc_inner_req.py
	================
	import asyncio
	import logging
	import base64
	from ..constants import DATA_CHANNEL_TYPE, WebRTCConnectionMethod
	from ..util import generate_uuid

	class WebRTCChannelProbeResponse:
		def __init__(self, channel, pub_sub):
			self.channel = channel
			self.publish = pub_sub.publish_without_callback
			
		def handle_response(self, info):
			self.publish(
				"",
				info,
				DATA_CHANNEL_TYPE["RTC_INNER_REQ"],
			)

	class WebRTCDataChannelNetworkStatus:
		def __init__(self, conn, channel, pub_sub):
			self.conn = conn
			self.channel = channel
			self.publish = pub_sub.publish
			self.network_timer = None
			self.network_status = ""
			self.on_network_status_callbacks = []
		
		def set_on_network_status_callback(self, callback):
			"""Register a callback to be called upon validation."""
			if callback and callable(callback):
				self.on_network_status_callbacks.append(callback)

		def start_network_status_fetch(self):
			"""Start sending network status requests every 1 second."""
			self.network_timer = asyncio.get_event_loop().call_later(1, self.schedule_network_status_request)
		
		def stop_network_status_fetch(self):
			"""Stop the network status fetch."""
			if self.network_timer:
				self.network_timer.cancel()
				self.network_timer = None
		
		def schedule_network_status_request(self):
			"""Schedule the next network status request."""
			asyncio.create_task(self.send_network_status_request())

		async def send_network_status_request(self):
			"""Send a network status request."""
			data = {
				"req_type": "public_network_status",
				"uuid": generate_uuid()
			}
			try:
				response = await self.publish(
					"",
					data,
					DATA_CHANNEL_TYPE["RTC_INNER_REQ"],
				)
				self.handle_response(response.get("info"))
			except Exception as e:
				logging.error("Failed to publish:", e)
			
		def handle_response(self, info):
			"""Handle a received network status message."""
			logging.info("Network status message received.")
			status = info.get("status")
			if status == "Undefined" or status == "NetworkStatus.DISCONNECTED":
				# Schedule the next network status request in 0.5s
				self.network_timer = asyncio.get_event_loop().call_later(0.5, self.schedule_network_status_request)

			elif status == "NetworkStatus.ON_4G_CONNECTED":
				self.network_status = "4G"
				self.stop_network_status_fetch()
			elif status == "NetworkStatus.ON_WIFI_CONNECTED":
				if self.conn.connectionMethod == WebRTCConnectionMethod.Remote:
					self.network_status = "STA-T"
				else:
					self.network_status = "STA-L"
			
			if status == "NetworkStatus.ON_4G_CONNECTED" or status == "NetworkStatus.ON_WIFI_CONNECTED":
				for callback in self.on_network_status_callbacks:
					callback(self.network_status)
				self.stop_network_status_fetch()


	class WebRTCDataChannelFileUploader:
		
		def __init__(self, channel, pub_sub):
			self.channel = channel
			self.publish = pub_sub.publish
			self.cancel_upload = False
		
		def slice_base64_into_chunks(self, data, chunk_size):
			"""Slices the base64 data into chunks of the given size."""
			return [data[i:i + chunk_size] for i in range(0, len(data), chunk_size)]
		
		
		async def upload_file(self, data, file_path, chunk_size=60*1024, progress_callback=None):
			"""Uploads a file in chunks with the possibility to cancel the upload."""
			
			# Encode the data to Base64
			encoded_data = base64.b64encode(data).decode('utf-8')
			
			print("Total size after Base64 encoding:", len(encoded_data))
			chunks = self.slice_base64_into_chunks(encoded_data, chunk_size)
			total_chunks = len(chunks)
			
			self.cancel_upload = False
			
			for i, chunk in enumerate(chunks):
				if self.cancel_upload:
					print("Upload canceled.")
					return "cancel"
				
				if i % 5 == 0:
					await asyncio.sleep(0.5)
				
				uuid = generate_uuid()
				req_uuid = f"upload_req_{uuid}"
				
				message = {
					"req_type": "push_static_file",
					"req_uuid": req_uuid,
					"related_bussiness": "uslam_final_pcd",
					"file_md5": "null",
					"file_path": file_path,
					"file_size_after_b64": len(encoded_data),
					"file": {
						"chunk_index": i + 1,
						"total_chunk_num": total_chunks,
						"chunk_data": chunk,
						"chunk_data_size": len(chunk)
					}
				}
				
				self.publish("", message, DATA_CHANNEL_TYPE["RTC_INNER_REQ"])
				
				if progress_callback:
					progress_callback(int(((i + 1) / total_chunks) * 100))
			
			return "ok"
		
		def cancel(self):
			"""Cancel the ongoing upload."""
			self.cancel_upload = True


	class WebRTCDataChannelFileDownloader:
		
		def __init__(self, channel, pub_sub):
			self.channel = channel
			self.publish = pub_sub.publish
			self.cancel_download = False
			self.chunk_data_storage = {}

		async def download_file(self, file_path, chunk_size=60*1024, progress_callback=None):
			"""Downloads a file in chunks with the possibility to cancel the download."""
			self.cancel_download = False

			try:
				uuid = generate_uuid()

				# Send the request to download the file
				request_message = {
					"req_type": "request_static_file",
					"req_uuid": f"req_{uuid}",
					"related_bussiness": "uslam_final_pcd",
					"file_md5": "null",
					"file_path": file_path
				}
				response = await self.publish("", request_message, DATA_CHANNEL_TYPE["RTC_INNER_REQ"])

				# Check if the download was canceled
				if self.cancel_download:
					logging.info("Download canceled.")
					return "cancel"
				
				# Extract the complete data after all chunks have been combined in the resolver
				complete_data = response.get("info", {}).get("file", {}).get("data")

				if not complete_data:
					logging.error("Failed to get the file data.")
					return "error"
				
				# Decode the Base64-encoded data
				decoded_data = base64.b64decode(complete_data)

				# Call progress_callback with 100% progress since the download is complete
				if progress_callback:
					progress_callback(100)

				return decoded_data

			except Exception as e:
				logging.error("Failed to download file:", e)
				return "error"

	def cancel(self):
		"""Cancel the ongoing download."""
		self.cancel_download = True

	class WebRTCDataChannelRTCInnerReq:
		def __init__(self, conn, channel, pub_sub):
			self.conn = conn
			self.channel = channel

			self.network_status = WebRTCDataChannelNetworkStatus(self.conn, self.channel, pub_sub)
			self.probe_res = WebRTCChannelProbeResponse(self.channel, pub_sub)
		
		def handle_response(self, msg):
			"""Handle a received network status message."""
			info = msg.get("info")
			req_type = info.get("req_type")
			if req_type == 'rtt_probe_send_from_mechine':
				self.probe_res.handle_response(info)

	================
	File: go2_webrtc_driver/msgs/validation.py
	================
	import logging
	import base64
	from ..constants import DATA_CHANNEL_TYPE

	class WebRTCDataChannelValidaton:
		def __init__(self, channel, pub_sub):
			self.channel = channel
			self.publish = pub_sub.publish
			self.on_validate_callbacks = []
			self.key = ""

		def set_on_validate_callback(self, callback):
			"""Register a callback to be called upon validation."""
			if callback and callable(callback):
				self.on_validate_callbacks.append(callback)
		
		async def handle_response(self, message):
			if message.get("data") == "Validation Ok.":
				logging.info("Validation succeed")
				for callback in self.on_validate_callbacks:
					callback()
			else:
				self.channel._setReadyState("open")
				self.key = message.get("data")
				await self.publish(
					"",
					self.encrypt_key(self.key),
					DATA_CHANNEL_TYPE["VALIDATION"],
				)

		async def handle_err_response(self, message):
			if message.get("info") == "Validation Needed.":
				await self.publish(
					"",
					self.encrypt_key(self.key),
					DATA_CHANNEL_TYPE["VALIDATION"],
				)
			

		@staticmethod
		def hex_to_base64(hex_str):
			# Convert hex string to bytes
			bytes_array = bytes.fromhex(hex_str)
			# Encode the bytes to Base64 and return as a string
			return base64.b64encode(bytes_array).decode("utf-8")
		
		@staticmethod
		def encrypt_by_md5(input_str):
			import hashlib
			# Create an MD5 hash object
			hash_obj = hashlib.md5()
			# Update the hash object with the bytes of the input string
			hash_obj.update(input_str.encode("utf-8"))
			# Return the hex digest of the hash
			return hash_obj.hexdigest()

		@staticmethod
		def encrypt_key(key):
			# Append the prefix to the key
			prefixed_key = f"UnitreeGo2_{key}"
			# Encrypt the key using MD5 and convert to hex string
			encrypted = WebRTCDataChannelValidaton.encrypt_by_md5(prefixed_key)
			# Convert the hex string to Base64
			return WebRTCDataChannelValidaton.hex_to_base64(encrypted)

	================
	File: go2_webrtc_driver/multicast_scanner.py
	================
	import socket
	import struct
	import json
	import logging

	RECV_PORT = 10134  # Port where the devices will send the multicast responses
	MULTICAST_GROUP = '231.1.1.1'  # Multicast group IP address
	MULTICAST_PORT = 10131  # Port to send multicast query to devices

	def discover_ip_sn(timeout=2):
		print("Discovering devices on the network...")

		# Use a dictionary to store the serial number to IP mapping
		serial_to_ip = {}

		# Create a UDP socket
		sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
		sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

		# Bind the socket to the port
		sock.bind(('', RECV_PORT))

		# Tell the operating system to add the socket to the multicast group
		# on all interfaces.
		mreq = struct.pack("4sl", socket.inet_aton(MULTICAST_GROUP), socket.INADDR_ANY)
		sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)

		# Send a multicast query to discover devices
		query_message = json.dumps({"name": "unitree_dapengche"})
		
		try:
			sock.sendto(query_message.encode('utf-8'), (MULTICAST_GROUP, MULTICAST_PORT))
		except Exception as e:
			logging.error(f"Error sending multicast query: {e}")
			sock.close()
			return serial_to_ip

		# Set a timeout for receiving responses
		sock.settimeout(timeout)

		try:
			while True:
				# Receive the response from the device
				data, addr = sock.recvfrom(1024)
				message = data.decode('utf-8')
				# Convert the JSON message to a dictionary
				message_dict = json.loads(message)
				if "sn" in message_dict:
					serial_number = message_dict["sn"]
					ip_address = message_dict.get("ip", addr[0])
					serial_to_ip[serial_number] = ip_address
					print(f"Discovered device: {serial_number} at {ip_address}")
		except socket.timeout:
			logging.info("Timeout reached, stopping listening.")
		except json.JSONDecodeError as e:
			logging.error(f"Error decoding JSON message: {e}")
		except Exception as e:
			logging.error(f"An error occurred: {e}")
		finally:
			# Close the socket
			sock.close()

		return serial_to_ip

	if __name__ == '__main__':
		print("Discovering devices on the network...")
		serial_to_ip = discover_ip_sn(timeout=3)
		print("\nDiscovered devices:")
		for serial_number, ip_address in serial_to_ip.items():
			print(f"Serial Number: {serial_number}, IP Address: {ip_address}")

	================
	File: go2_webrtc_driver/unitree_auth.py
	================
	import hashlib
	import time
	import requests
	import urllib.parse
	import base64
	import logging
	import json
	import sys
	from Crypto.PublicKey import RSA
	from .encryption import aes_encrypt, generate_aes_key, rsa_encrypt, aes_decrypt, rsa_load_public_key

	def _calc_local_path_ending(data1):
		# Initialize an array of strings
		strArr = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"]

		# Extract the last 10 characters of data1
		last_10_chars = data1[-10:]

		# Split the last 10 characters into chunks of size 2
		chunked = [last_10_chars[i:i + 2] for i in range(0, len(last_10_chars), 2)]

		# Initialize an empty list to store indices
		arrayList = []

		# Iterate over the chunks and find the index of the second character in strArr
		for chunk in chunked:
			if len(chunk) > 1:
				second_char = chunk[1]
				try:
					index = strArr.index(second_char)
					arrayList.append(index)
				except ValueError:
					# Handle case where the character is not found in strArr
					print(f"Character {second_char} not found in strArr.")

		# Convert arrayList to a string without separators
		joinToString = ''.join(map(str, arrayList))

		return joinToString

	def make_remote_request(path, body, token, method="GET"):
		# Constants
		APP_SIGN_SECRET = "XyvkwK45hp5PHfA8"
		UM_CHANNEL_KEY = "UMENG_CHANNEL"
		BASE_URL = "https://global-robot-api.unitree.com/"
		
		# Current timestamp and nonce
		app_timestamp = str(int(round(time.time() * 1000)))
		app_nonce = hashlib.md5(app_timestamp.encode()).hexdigest()
		
		# Generating app sign
		sign_str = f"{APP_SIGN_SECRET}{app_timestamp}{app_nonce}"
		app_sign = hashlib.md5(sign_str.encode()).hexdigest()
		
		# Get system's timezone offset in seconds and convert it to hours and minutes
		timezone_offset = time.localtime().tm_gmtoff // 3600
		minutes_offset = abs(time.localtime().tm_gmtoff % 3600 // 60)
		sign = "+" if timezone_offset >= 0 else "-"
		app_timezone = f"GMT{sign}{abs(timezone_offset):02d}:{minutes_offset:02d}"
		
		# Headers
		headers = {
			"Content-Type": "application/x-www-form-urlencoded",
			"DeviceId": "Samsung/GalaxyS20/SM-G981B/s20/10/29",
			"AppTimezone": app_timezone,
			"DevicePlatform": "Android",
			"DeviceModel": "SM-G981B",
			"SystemVersion": "29",
			"AppVersion": "1.8.0",
			"AppLocale": "en_US",
			"AppTimestamp": app_timestamp,
			"AppNonce": app_nonce,
			"AppSign": app_sign,
			"Channel": UM_CHANNEL_KEY,
			"Token": token,
			"AppName": "Go2"
		}
		
		# Full URL
		url = BASE_URL + path
		
		if method.upper() == "GET":
			# Convert body dictionary to query parameters for GET request
			params = urllib.parse.urlencode(body)
			response = requests.get(url, params=params, headers=headers)
		else:
			# URL-encode the body for POST request
			encoded_body = urllib.parse.urlencode(body)
			response = requests.post(url, data=encoded_body, headers=headers)

		# Return the response as JSON
		return response.json()

	def make_local_request(path, body=None, headers=None):
		try:
			# Send POST request with provided path, body, and headers
			response = requests.post(url=path, data=body, headers=headers)

			# Check if the request was successful (status code 200)
			response.raise_for_status()  # Raises an HTTPError for bad responses (4xx, 5xx)

			if response.status_code == 200:
				return response  # Returning the whole response object if needed
			else:
				# Handle non-200 responses
				return None

		except requests.exceptions.RequestException as e:
			# Handle any exception related to the request (e.g., connection errors, timeouts)
			logging.error(f"An error occurred: {e}")
			return None

	# Function to send SDP to peer and receive the answer
	def send_sdp_to_remote_peer(serial: str, sdp: str, access_token: str, public_key: RSA.RsaKey) -> str:
		logging.info("Sending SDP to Go2...")
		aes_key = generate_aes_key()
		path = "webrtc/connect"
		body = {
			"sn": serial,
			"sk": rsa_encrypt(aes_key, public_key),
			"data": aes_encrypt(sdp, aes_key),
			"timeout": 5
		}
		response = make_remote_request(path, body, token=access_token, method="POST")
		if response.get("code") == 100:
			logging.info("Received SDP Answer from Go2!")
			return aes_decrypt(response['data'], aes_key)
		elif response.get("code") == 1000:
			print("Device not online")
			sys.exit(1)
		else:
			raise ValueError(f"Failed to receive SDP Answer: {response}")
		


	def send_sdp_to_local_peer(ip, sdp):
		try:
			# Try the old method first
			logging.info("Trying to send SDP using the old method...")
			response = send_sdp_to_local_peer_old_method(ip, sdp)
			if response:
				logging.info("SDP successfully sent using the old method.")
				return response
			else:
				logging.warning("Old method failed, trying the new method...")
		except Exception as e:
			logging.error(f"An error occurred with the old method: {e}")
			logging.info("Falling back to the new method...")

		# Now try the new method after the old method has failed
		try:
			response = send_sdp_to_local_peer_new_method(ip, sdp)  # Use the new method here
			if response:
				logging.info("SDP successfully sent using the new method.")
				return response
			else:
				logging.error("New method failed to send SDP.")
				return None
		except Exception as e:
			logging.error(f"An error occurred with the new method: {e}")
			return None


	def send_sdp_to_local_peer_old_method(ip, sdp):
		"""
		Sends an SDP message to a local peer using an HTTP POST request.
		
		Args:
			ip (str): The IP address of the local peer to send the SDP message.
			sdp (dict): The SDP message to be sent in the request body.
			
		Returns:
			response: The response from the local peer if the request is successful, otherwise None.
		"""
		try:
			# Define the URL for the POST request
			url = f"http://{ip}:8081/offer"

			# Define headers for the POST request
			headers = {'Content-Type': 'application/json'}
			
			# Send the POST request with the SDP body (convert the dict to JSON)
			response = make_local_request(url, body=sdp, headers=headers)
			
			# Check if the response is valid
			if response and response.status_code == 200:
				logging.debug(f"Recieved SDP: {response.text}")
				return response.text
			else:
				raise ValueError(f"Failed to receive SDP Answer: {response.status_code if response else 'No response'}")

		except requests.exceptions.RequestException as e:
			# Handle any exceptions that occur during the request
			logging.error(f"An error occurred while sending the SDP: {e}")
			return None

	def send_sdp_to_local_peer_new_method(ip, sdp):
		try:
			url = f"http://{ip}:9991/con_notify"

			# Initial request to get public key information
			response = make_local_request(url, body=None, headers=None)
			
			# Check if the response status code is 200 (OK)
			if response:
				# Decode the response text from base64
				decoded_response = base64.b64decode(response.text).decode('utf-8')
				logging.debug(f"Recieved con_notify response: {decoded_response}")

				# Parse the decoded response as JSON
				decoded_json = json.loads(decoded_response)
				
				# Extract the 'data1' field from the JSON
				data1 = decoded_json.get('data1')

				# Extract the public key from 'data1'
				public_key_pem = data1[10:len(data1)-10]
				path_ending = _calc_local_path_ending(data1)

				# Generate AES key
				aes_key = generate_aes_key()

				# Load Public Key
				public_key = rsa_load_public_key(public_key_pem)

				# Encrypt the SDP and AES key
				body = {
					"data1": aes_encrypt(sdp, aes_key),
					"data2": rsa_encrypt(aes_key, public_key),
				}

				# URL for the second request
				url = f"http://{ip}:9991/con_ing_{path_ending}"

				# Set the appropriate headers for URL-encoded form data
				headers = {'Content-Type': 'application/x-www-form-urlencoded'}

				# Send the encrypted data via POST
				response = make_local_request(url, body=json.dumps(body), headers=headers)

				# If response is successful, decrypt it
				if response:
					decrypted_response = aes_decrypt(response.text, aes_key)
					logging.debug(f"Recieved con_ing_{path_ending} response: {decrypted_response}")
					return decrypted_response
			else:
				raise ValueError("Failed to receive initial public key response.")

		except requests.exceptions.RequestException as e:
			# Handle any exceptions that occur during the request
			logging.error(f"An error occurred while sending the SDP: {e}")
			return None
		except json.JSONDecodeError as e:
			# Handle JSON decoding errors
			logging.error(f"An error occurred while decoding JSON: {e}")
			return None
		except base64.binascii.Error as e:
			# Handle base64 decoding errors
			logging.error(f"An error occurred while decoding base64: {e}")
			return None

	================
	File: go2_webrtc_driver/util.py
	================
	import hashlib
	import json
	import logging
	import random
	import requests
	import time
	import sys
	from Crypto.PublicKey import RSA
	from .unitree_auth import make_remote_request
	from .encryption import rsa_encrypt, rsa_load_public_key, aes_decrypt, generate_aes_key

	# Function to generate MD5 hash of a string

	def _generate_md5(string: str) -> str:
		md5_hash = hashlib.md5(string.encode())
		return md5_hash.hexdigest()

	def generate_uuid():
		def replace_char(char):
			rand = random.randint(0, 15)
			if char == "x":
				return format(rand, 'x')
			elif char == "y":
				return format((rand & 0x3) | 0x8, 'x')

		uuid_template = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"
		return ''.join(replace_char(char) if char in 'xy' else char for char in uuid_template)


	def get_nested_field(message, *fields):
		current_level = message
		for field in fields:
			if isinstance(current_level, dict) and field in current_level:
				current_level = current_level[field]
			else:
				return None
		return current_level

	# Function to obtain a fresh token from the backend server
	def fetch_token(email: str, password: str) -> str:
		logging.info("Obtaining TOKEN...")
		path = "login/email"
		body = {
			'email': email,
			'password': _generate_md5(password)
		}
		response = make_remote_request(path, body, token="", method="POST")
		if response.get("code") == 100:
			data = response.get("data")
			access_token = data.get("accessToken")
			return access_token
		else:
			logging.error("Failed to receive token")
			return None


	# Function to obtain a public key
	def fetch_public_key() -> RSA.RsaKey:
		logging.info("Obtaining a Public key...")
		path = "system/pubKey"
		
		try:
			# Attempt to make the request
			response = make_remote_request(path, {}, token="", method="GET")

			if response.get("code") == 100:
				public_key_pem = response.get("data")
				return rsa_load_public_key(public_key_pem)
			else:
				logging.error("Failed to receive public key")
				return None

		except requests.exceptions.ConnectionError as e:
			# Handle no internet connection or other connection errors
			logging.warning("No internet connection or failed to connect to the server. Unable to fetch public key.")
			logging.error(f"Connection error: {e}")
			return None
		except requests.exceptions.RequestException as e:
			# Handle other request exceptions
			logging.error(f"An error occurred while fetching the public key: {e}")
			return None


	# Function to obtain TURN server info
	def fetch_turn_server_info(serial: str, access_token: str, public_key: RSA.RsaKey) -> dict:
		logging.info("Obtaining TURN server info...")
		aes_key = generate_aes_key()
		path = "webrtc/account"
		body = {
			"sn": serial,
			"sk": rsa_encrypt(aes_key, public_key)
		}
		response = make_remote_request(path, body, token=access_token, method="POST")
		if response.get("code") == 100:
			return json.loads(aes_decrypt(response['data'], aes_key))
		else:
			logging.error("Failed to receive TURN server info")
			return None

	def print_status(status_type, status_message):
		current_time = time.strftime("%H:%M:%S")
		print(f"ðŸ•’ {status_type:<25}: {status_message:<15} ({current_time})")

	================
	File: go2_webrtc_driver/webrtc_audio.py
	================
	from aiortc import AudioStreamTrack, RTCRtpSender
	import logging
	import sounddevice as sd
	import numpy as np
	import wave


	class WebRTCAudioChannel:
		def __init__(self, pc, datachannel) -> None:
			self.pc = pc
			self.pc.addTransceiver("audio", direction="sendrecv")
			self.datachannel = datachannel

			# List to hold multiple callbacks
			self.track_callbacks = []
			
		async def frame_handler(self, frame):
			logging.info("Receiving audio frame")

			# Trigger all registered callbacks
			for callback in self.track_callbacks:
				try:
					# Call each callback function and pass the track
					await callback(frame)
				except Exception as e:
					logging.error(f"Error in callback {callback}: {e}")
		
		def add_track_callback(self, callback):
			"""
			Adds a callback to be triggered when an audio track is received.
			"""
			if callable(callback):
				self.track_callbacks.append(callback)
			else:
				logging.warning(f"Callback {callback} is not callable.")  

		def switchAudioChannel(self, switch: bool):
			self.datachannel.switchAudioChannel(switch)

	================
	File: go2_webrtc_driver/webrtc_audiohub.py
	================
	import logging
	import json
	import base64
	import time
	import uuid
	import os
	import hashlib
	from pydub import AudioSegment
	from go2_webrtc_driver.constants import AUDIO_API
	from go2_webrtc_driver.webrtc_driver import Go2WebRTCConnection
	import asyncio

	CHUNK_SIZE = 61440

	class WebRTCAudioHub:
		def __init__(self, connection: Go2WebRTCConnection, logger: logging.Logger = None):
			self.logger = logger.getChild(self.__class__.__name__) if logger else logging.getLogger(self.__class__.__name__)
			self.conn = connection
			self.data_channel = None
			self._setup_data_channel()

		def _setup_data_channel(self):
			"""Setup the WebRTC data channel for audio control"""
			if not self.conn.datachannel:
				self.logger.error("WebRTC connection not established")
				raise RuntimeError("WebRTC connection not established")
			self.data_channel = self.conn.datachannel

		async def get_audio_list(self):
			"""Get list of available audio files"""
			response = await self.data_channel.pub_sub.publish_request_new(
				"rt/api/audiohub/request",
				{
					"api_id": AUDIO_API['GET_AUDIO_LIST'],
					"parameter": json.dumps({})
				}
			)
			return response

		async def play_by_uuid(self, uuid):
			"""Play audio by UUID"""
			await self.data_channel.pub_sub.publish_request_new(
				"rt/api/audiohub/request",
				{
					"api_id": AUDIO_API['SELECT_START_PLAY'],
					"parameter": json.dumps({
						'unique_id': uuid
					})
				}
			)

		async def pause(self):
			"""Pause current audio playback"""
			await self.data_channel.pub_sub.publish_request_new(
				"rt/api/audiohub/request",
				{
					"api_id": AUDIO_API['PAUSE'],
					"parameter": json.dumps({})
				}
			)

		async def resume(self):
			"""Resume paused audio playback"""
			await self.data_channel.pub_sub.publish_request_new(
				"rt/api/audiohub/request",
				{
					"api_id": AUDIO_API['UNSUSPEND'],
					"parameter": json.dumps({})
				}
			)

		async def set_play_mode(self, play_mode):
			"""Set audio play mode (single_cycle, no_cycle, list_loop)"""
			await self.data_channel.pub_sub.publish_request_new(
				"rt/api/audiohub/request",
				{
					"api_id": AUDIO_API['SET_PLAY_MODE'],
					"parameter": json.dumps({
						'play_mode': play_mode
					})
				}
			)

		async def rename_record(self, uuid, new_name):
			"""Rename an audio record"""
			await self.data_channel.pub_sub.publish_request_new(
				"rt/api/audiohub/request",
				{
					"api_id": AUDIO_API['SELECT_RENAME'],
					"parameter": json.dumps({
						'unique_id': uuid,
						'new_name': new_name
					})
				}
			)

		async def delete_record(self, uuid):
			"""Delete an audio record"""
			await self.data_channel.pub_sub.publish_request_new(
				"rt/api/audiohub/request",
				{
					"api_id": AUDIO_API['SELECT_DELETE'],
					"parameter": json.dumps({
						'unique_id': uuid
					})
				}
			)

		async def get_play_mode(self):
			"""Get current play mode"""
			response = await self.data_channel.pub_sub.publish_request_new(
				"rt/api/audiohub/request",
				{
					"api_id": AUDIO_API['GET_PLAY_MODE'],
					"parameter": json.dumps({})
				}
			)
			return response

		async def upload_audio_file(self, audiofile_path):
			"""Upload audio file (MP3 or WAV)"""
			# Convert MP3 to WAV if necessary
			if audiofile_path.endswith(".mp3"):
				self.logger.info("Converting MP3 to WAV")
				audio = AudioSegment.from_mp3(audiofile_path)
				# Set specific audio parameters for compatibility
				audio = audio.set_frame_rate(44100)  # Standard sample rate
				wav_file_path = audiofile_path.replace('.mp3', '.wav')
				audio.export(wav_file_path, format='wav', parameters=["-ar", "44100"])
			else:
				wav_file_path = audiofile_path
			
			# Read the WAV file
			with open(wav_file_path, 'rb') as f:
				audio_data = f.read()

			# Generate a unique ID for the audio file
			unique_id = str(uuid.uuid4())
			
			try:
				# Calculate MD5 of the file
				file_md5 = hashlib.md5(audio_data).hexdigest()
				
				# Convert to base64
				b64_data = base64.b64encode(audio_data).decode('utf-8')
				
				# Split into smaller chunks (4KB each)
				chunk_size = 4096
				chunks = [b64_data[i:i + chunk_size] for i in range(0, len(b64_data), chunk_size)]
				total_chunks = len(chunks)
				
				self.logger.info(f"Splitting file into {total_chunks} chunks")

				# Send each chunk
				for i, chunk in enumerate(chunks, 1):
					parameter = {
						'file_name': os.path.splitext(os.path.basename(audiofile_path))[0],
						'file_type': 'wav',
						'file_size': len(audio_data),
						'current_block_index': i,
						'total_block_number': total_chunks,
						'block_content': chunk,
						'current_block_size': len(chunk),
						'file_md5': file_md5,
						'create_time': int(time.time() * 1000)
					}
					print(json.dumps(parameter, ensure_ascii=True))
					# Send the chunk
					self.logger.info(f"Sending chunk {i}/{total_chunks}")
					
					response = await self.data_channel.pub_sub.publish_request_new(
						"rt/api/audiohub/request",
						{
							"api_id": AUDIO_API['UPLOAD_AUDIO_FILE'],
							"parameter": json.dumps(parameter, ensure_ascii=True)
						}
					)
					
					# Wait a small amount between chunks
					await asyncio.sleep(0.1)
					
				self.logger.info("All chunks sent")
				return response
				
			except Exception as e:
				self.logger.error(f"Error uploading audio file: {e}")
				raise

		async def enter_megaphone(self):
			"""Enter megaphone mode"""
			await self.data_channel.pub_sub.publish_request_new(
				"rt/api/audiohub/request",
				{
					"api_id": AUDIO_API['ENTER_MEGAPHONE'],
					"parameter": json.dumps({})
				}
			)

		async def exit_megaphone(self):
			"""Exit megaphone mode"""
			await self.data_channel.pub_sub.publish_request_new(
				"rt/api/audiohub/request",
				{
					"api_id": AUDIO_API['EXIT_MEGAPHONE'],
					"parameter": json.dumps({})
				}
			)

		async def upload_megaphone(self, audiofile_path):
			"""Upload audio file (MP3 or WAV)"""
			# Convert MP3 to WAV if necessary
			if audiofile_path.endswith(".mp3"):
				self.logger.info("Converting MP3 to WAV")
				audio = AudioSegment.from_mp3(audiofile_path)
				# Set specific audio parameters for compatibility
				audio = audio.set_frame_rate(44100)  # Standard sample rate
				wav_file_path = audiofile_path.replace('.mp3', '.wav')
				audio.export(wav_file_path, format='wav', parameters=["-ar", "44100"])
			else:
				wav_file_path = audiofile_path

			# Read and chunk the WAV file
			with open(wav_file_path, 'rb') as f:
				audio_data = f.read()

			try:
				# Calculate MD5 of the file
				file_md5 = hashlib.md5(audio_data).hexdigest()
				
				# Convert to base64
				b64_data = base64.b64encode(audio_data).decode('utf-8')
				
				# Split into smaller chunks (4KB each)
				chunk_size = 4096
				chunks = [b64_data[i:i + chunk_size] for i in range(0, len(b64_data), chunk_size)]
				total_chunks = len(chunks)
				
				self.logger.info(f"Splitting file into {total_chunks} chunks")

				# Send each chunk
				for i, chunk in enumerate(chunks, 1):
					parameter = {
						'current_block_size': len(chunk),
						'block_content': chunk,
						'current_block_index': i,
						'total_block_number': total_chunks
					}
					print(json.dumps(parameter, ensure_ascii=True))
					# Send the chunk
					self.logger.info(f"Sending chunk {i}/{total_chunks}")
					
					response = await self.data_channel.pub_sub.publish_request_new(
						"rt/api/audiohub/request",
						{
							"api_id": AUDIO_API['UPLOAD_MEGAPHONE'],
							"parameter": json.dumps(parameter, ensure_ascii=True)
						}
					)
					
					# Wait a small amount between chunks
					await asyncio.sleep(0.1)
					
				self.logger.info("All chunks sent")
				return response
			except Exception as e:
				self.logger.error(f"Error uploading audio file: {e}")
				raise

	================
	File: go2_webrtc_driver/webrtc_datachannel.py
	================
	import asyncio
	import json
	import logging
	import struct
	import sys
	from .msgs.pub_sub import WebRTCDataChannelPubSub
	from .lidar.lidar_decoder import LidarDecoder
	from .msgs.heartbeat import WebRTCDataChannelHeartBeat
	from .msgs.validation import WebRTCDataChannelValidaton
	from .msgs.rtc_inner_req import WebRTCDataChannelRTCInnerReq
	from .util import print_status
	from .msgs.error_handler import handle_error

	from .constants import DATA_CHANNEL_TYPE

	decoder = LidarDecoder()

	class WebRTCDataChannel:
		def __init__(self, conn, pc) -> None:
			self.channel = pc.createDataChannel("data")
			self.data_channel_opened = False
			self.conn = conn

			self.pub_sub = WebRTCDataChannelPubSub(self.channel)

			self.heartbeat = WebRTCDataChannelHeartBeat(self.channel, self.pub_sub)
			self.validaton = WebRTCDataChannelValidaton(self.channel, self.pub_sub)
			self.rtc_inner_req = WebRTCDataChannelRTCInnerReq(self.conn, self.channel, self.pub_sub)

			#Event handler for Validation succeed
			def on_validate():
				self.data_channel_opened = True
				self.heartbeat.start_heartbeat()
				self.rtc_inner_req.network_status.start_network_status_fetch()
				print_status("Data Channel Verification", "âœ… OK")
				

			self.validaton.set_on_validate_callback(on_validate)

			#Event handler for Network status Update
			def on_network_status(mode):
				print(f"Go2 connection mode: {mode}")

			self.rtc_inner_req.network_status.set_on_network_status_callback(on_network_status)

			# Event handler for data channel open
			@self.channel.on("open")
			def on_open():
				logging.info("Data channel opened")

			# Event handler for data channel close
			@self.channel.on("close")
			def on_close():
				logging.info("Data channel closed")
				self.data_channel_opened = False
				self.heartbeat.stop_heartbeat()
				self.rtc_inner_req.network_status.stop_network_status_fetch()
				
			# Event handler for data channel messages
			@self.channel.on("message")
			async def on_message(message):
				logging.info("Received message on data channel: %s", message)
				try:
				
					# Check if the message is not empty
					if not message:
						return

					# Determine how to parse the 'data' field
					if isinstance(message, str):
						parsed_data = json.loads(message)
					elif isinstance(message, bytes):
						parsed_data = WebRTCDataChannel.deal_array_buffer(message)
					
					# Resolve any pending futures or callbacks associated with this message
					self.pub_sub.run_resolve(parsed_data)

					# Handle the response
					await self.handle_response(parsed_data)
			
				except json.JSONDecodeError:
					logging.error("Failed to decode JSON message: %s", message, exc_info=True)
				except Exception as error:
					logging.error("Error processing WebRTC data", exc_info=True)


		async def handle_response(self, msg: dict):
			msg_type = msg["type"]

			if msg_type == DATA_CHANNEL_TYPE["VALIDATION"]:
				await self.validaton.handle_response(msg)
			elif msg_type == DATA_CHANNEL_TYPE["RTC_INNER_REQ"]:
				self.rtc_inner_req.handle_response(msg)
			elif msg_type == DATA_CHANNEL_TYPE["HEARTBEAT"]:
				self.heartbeat.handle_response(msg)
			elif msg_type in {DATA_CHANNEL_TYPE["ERRORS"], DATA_CHANNEL_TYPE["ADD_ERROR"], DATA_CHANNEL_TYPE["RM_ERROR"]}:
				handle_error(msg)
			elif msg_type == DATA_CHANNEL_TYPE["ERR"]:
				await self.validaton.handle_err_response(msg)
			

		async def wait_datachannel_open(self, timeout=5):
			"""Waits for the data channel to open asynchronously."""
			try:
				await asyncio.wait_for(self._wait_for_open(), timeout)
			except asyncio.TimeoutError:
				print("Data channel did not open in time")
				sys.exit(1)

		async def _wait_for_open(self):
			"""Internal function that waits for the data channel to be opened."""
			while not self.data_channel_opened:
				await asyncio.sleep(0.1)
		
		@staticmethod
		def deal_array_buffer(buffer):
			header_1, header_2 = struct.unpack_from('<HH', buffer, 0)
			if header_1 == 2 and header_2 == 0:
				return WebRTCDataChannel.deal_array_buffer_for_lidar(buffer[4:])
			else:
				return WebRTCDataChannel.deal_array_buffer_for_normal(buffer)
		@staticmethod
		def deal_array_buffer_for_normal(buffer):
			header_length, = struct.unpack_from('<H', buffer, 0)
			json_data = buffer[4:4 + header_length]
			binary_data = buffer[4 + header_length:]

			decoded_json = json.loads(json_data.decode('utf-8'))

			decoded_data = decoder.decode(binary_data, decoded_json['data'])

			decoded_json['data']['data'] = decoded_data
			return decoded_json
		@staticmethod
		def deal_array_buffer_for_lidar(buffer):
			header_length, = struct.unpack_from('<I', buffer, 0)
			json_data = buffer[8:8 + header_length]
			binary_data = buffer[8 + header_length:]

			decoded_json = json.loads(json_data.decode('utf-8'))

			decoded_data = decoder.decode(binary_data, decoded_json['data'])

			decoded_json['data']['data'] = decoded_data
			return decoded_json

		
		#Should turn it on when subscribed to ulidar topic
		async def disableTrafficSaving(self, switch: bool):
			data = {
				"req_type": "disable_traffic_saving",
				"instruction": "on" if switch else "off"
			}
			response = await self.pub_sub.publish(
				"",
				data,
				DATA_CHANNEL_TYPE["RTC_INNER_REQ"],
			)
			if response['info']['execution'] == "ok":
				print(f"DisableTrafficSavings: {data['instruction']}")
				return True
			return False

		
		#Enable/Disable video channel
		def switchVideoChannel(self, switch: bool):
			self.pub_sub.publish_without_callback(
				"",
				"on" if switch else "off",
				DATA_CHANNEL_TYPE["VID"],
			)
			print(f"Video channel: {'on' if switch else 'off'}")
		

		#Enable/Disable audio channel
		def switchAudioChannel(self, switch: bool):
			self.pub_sub.publish_without_callback(
				"",
				"on" if switch else "off",
				DATA_CHANNEL_TYPE["AUD"],
			)
			print(f"Audio channel: {'on' if switch else 'off'}")

	================
	File: go2_webrtc_driver/webrtc_driver.py
	================
	import asyncio
	import logging
	import json
	import sys
	from aiortc import RTCPeerConnection, RTCSessionDescription, RTCIceServer, RTCConfiguration
	from aiortc.contrib.media import MediaPlayer
	from .unitree_auth import send_sdp_to_local_peer, send_sdp_to_remote_peer
	from .webrtc_datachannel import WebRTCDataChannel
	from .webrtc_audio import WebRTCAudioChannel
	from .webrtc_video import WebRTCVideoChannel
	from .constants import DATA_CHANNEL_TYPE, WebRTCConnectionMethod
	from .util import fetch_public_key, fetch_token, fetch_turn_server_info, print_status
	from .multicast_scanner import discover_ip_sn

	# # Enable logging for debugging
	# logging.basicConfig(level=logging.INFO)

	class Go2WebRTCConnection:
		def __init__(self, connectionMethod: WebRTCConnectionMethod, serialNumber=None, ip=None, username=None, password=None) -> None:
			self.pc = None
			self.sn = serialNumber
			self.ip = ip
			self.connectionMethod = connectionMethod
			self.isConnected = False
			self.token = fetch_token(username, password) if username and password else ""

		async def connect(self):
			print_status("WebRTC connection", "ðŸŸ¡ started")
			if self.connectionMethod == WebRTCConnectionMethod.Remote:
				self.public_key = fetch_public_key()
				turn_server_info = fetch_turn_server_info(self.sn, self.token, self.public_key)
				await self.init_webrtc(turn_server_info)
			elif self.connectionMethod == WebRTCConnectionMethod.LocalSTA:
				if not self.ip and self.sn:
					discovered_ip_sn_addresses = discover_ip_sn()
					
					if discovered_ip_sn_addresses:
						if self.sn in discovered_ip_sn_addresses:
							self.ip = discovered_ip_sn_addresses[self.sn]
						else:
							raise ValueError("The provided serial number wasn't found on the network. Provide an IP address instead.")
					else:
						raise ValueError("No devices found on the network. Provide an IP address instead.")

				await self.init_webrtc(ip=self.ip)
			elif self.connectionMethod == WebRTCConnectionMethod.LocalAP:
				self.ip = "192.168.12.1"
				await self.init_webrtc(ip=self.ip)
		
		async def disconnect(self):
			if self.pc:
				await self.pc.close()
				self.pc = None
			self.isConnected = False
			print_status("WebRTC connection", "ðŸ”´ disconnected")

		async def reconnect(self):
			await self.disconnect()
			await self.connect()
			print_status("WebRTC connection", "ðŸŸ¢ reconnected")

		def create_webrtc_configuration(self, turn_server_info, stunEnable=True, turnEnable=True) -> RTCConfiguration:
			ice_servers = []

			if turn_server_info:
				username = turn_server_info.get("user")
				credential = turn_server_info.get("passwd")
				turn_url = turn_server_info.get("realm")
				
				if username and credential and turn_url:
					if turnEnable:
						ice_servers.append(
							RTCIceServer(
								urls=[turn_url],
								username=username,
								credential=credential
							)
						)
					if stunEnable:
						# Use Google's public STUN server
						stun_url = "stun:stun.l.google.com:19302"
						ice_servers.append(
							RTCIceServer(
								urls=[stun_url]
							)
						)
				else:
					raise ValueError("Invalid TURN server information")
			
			configuration = RTCConfiguration(
				iceServers=ice_servers
			)
			
			return configuration

		async def init_webrtc(self, turn_server_info=None, ip=None):
			configuration = self.create_webrtc_configuration(turn_server_info)
			self.pc = RTCPeerConnection(configuration)


			self.datachannel = WebRTCDataChannel(self, self.pc)

			self.audio = WebRTCAudioChannel(self.pc, self.datachannel)
			self.video = WebRTCVideoChannel(self.pc, self.datachannel)

			@self.pc.on("icegatheringstatechange")
			async def on_ice_gathering_state_change():
				state = self.pc.iceGatheringState
				if state == "new":
					print_status("ICE Gathering State", "ðŸ”µ new")
				elif state == "gathering":
					print_status("ICE Gathering State", "ðŸŸ¡ gathering")
				elif state == "complete":
					print_status("ICE Gathering State", "ðŸŸ¢ complete")


			@self.pc.on("iceconnectionstatechange")
			async def on_ice_connection_state_change():
				state = self.pc.iceConnectionState
				if state == "checking":
					print_status("ICE Connection State", "ðŸ”µ checking")
				elif state == "completed":
					print_status("ICE Connection State", "ðŸŸ¢ completed")
				elif state == "failed":
					print_status("ICE Connection State", "ðŸ”´ failed")
				elif state == "closed":
					print_status("ICE Connection State", "âš« closed")


			@self.pc.on("connectionstatechange")
			async def on_connection_state_change():
				state = self.pc.connectionState
				if state == "connecting":
					print_status("Peer Connection State", "ðŸ”µ connecting")
				elif state == "connected":
					self.isConnected= True
					print_status("Peer Connection State", "ðŸŸ¢ connected")
				elif state == "closed":
					self.isConnected= False
					print_status("Peer Connection State", "âš« closed")
				elif state == "failed":
					print_status("Peer Connection State", "ðŸ”´ failed")
			
			@self.pc.on("signalingstatechange")
			async def on_signaling_state_change():
				state = self.pc.signalingState
				if state == "stable":
					print_status("Signaling State", "ðŸŸ¢ stable")
				elif state == "have-local-offer":
					print_status("Signaling State", "ðŸŸ¡ have-local-offer")
				elif state == "have-remote-offer":
					print_status("Signaling State", "ðŸŸ¡ have-remote-offer")
				elif state == "closed":
					print_status("Signaling State", "âš« closed")
			
			@self.pc.on("track")
			async def on_track(track):
				logging.info("Track recieved: %s", track.kind)

				if track.kind == "video":
					#await for the first frame, #ToDo make the code more nicer
					frame = await track.recv()
					await self.video.track_handler(track)
					
				if track.kind == "audio":
					frame = await track.recv()
					while True:
						frame = await track.recv()
						await self.audio.frame_handler(frame)

			logging.info("Creating offer...")
			offer = await self.pc.createOffer()
			await self.pc.setLocalDescription(offer)

			if self.connectionMethod == WebRTCConnectionMethod.Remote:
				peer_answer_json = await self.get_answer_from_remote_peer(self.pc, turn_server_info)
			elif self.connectionMethod == WebRTCConnectionMethod.LocalSTA or self.connectionMethod == WebRTCConnectionMethod.LocalAP:
				peer_answer_json = await self.get_answer_from_local_peer(self.pc, self.ip)

			if peer_answer_json is not None:
				peer_answer = json.loads(peer_answer_json)
			else:
				print("Could not get SDP from the peer. Check if the Go2 is switched on")
				sys.exit(1)

			if peer_answer['sdp'] == "reject":
				print("Go2 is connected by another WebRTC client. Close your mobile APP and try again.")
				sys.exit(1)

			remote_sdp = RTCSessionDescription(sdp=peer_answer['sdp'], type=peer_answer['type']) 
			await self.pc.setRemoteDescription(remote_sdp)
	   
			await self.datachannel.wait_datachannel_open()

		
		async def get_answer_from_remote_peer(self, pc, turn_server_info):
			sdp_offer = pc.localDescription

			sdp_offer_json = {
				"id": "",
				"turnserver": turn_server_info,
				"sdp": sdp_offer.sdp,
				"type": sdp_offer.type,
				"token": self.token
			}

			logging.debug("Local SDP created: %s", sdp_offer_json)

			peer_answer_json = send_sdp_to_remote_peer(self.sn, json.dumps(sdp_offer_json), self.token, self.public_key)

			return peer_answer_json

		async def get_answer_from_local_peer(self, pc, ip):
			sdp_offer = pc.localDescription

			sdp_offer_json = {
				"id": "STA_localNetwork" if self.connectionMethod == WebRTCConnectionMethod.LocalSTA else "",
				"sdp": sdp_offer.sdp,
				"type": sdp_offer.type,
				"token": self.token
			}

			peer_answer_json = send_sdp_to_local_peer(ip, json.dumps(sdp_offer_json))

			return peer_answer_json

	================
	File: go2_webrtc_driver/webrtc_video.py
	================
	import logging
	from .webrtc_datachannel import WebRTCDataChannel
	from aiortc import RTCPeerConnection

	class WebRTCVideoChannel:
		def __init__(self, pc:RTCPeerConnection, datachannel:WebRTCDataChannel) -> None:
			self.pc = pc
			self.pc.addTransceiver("video", direction="recvonly")
			self.datachannel = datachannel
			# List to hold multiple callbacks
			self.track_callbacks = []
		
		def switchVideoChannel(self, switch: bool):
			self.datachannel.switchVideoChannel(switch)
		
		def add_track_callback(self, callback):
			"""
			Adds a callback to be triggered when an audio track is received.
			"""
			if callable(callback):
				self.track_callbacks.append(callback)
			else:
				logging.warning(f"Callback {callback} is not callable.")  
		
		async def track_handler(self, track):
			logging.info("Receiving video frame")
			# Trigger all registered callbacks
			for callback in self.track_callbacks:
				try:
					# Call each callback function and pass the track
					await callback(track)
				except Exception as e:
					logging.error(f"Error in callback {callback}: {e}")

	================
	File: README.md
	================
	# Full Unitree Go2 WebRTC Driver

	This repository contains a Python implementation of the WebRTC driver to connect to the Unitree Go2 Robot. WebRTC is used by the Unitree Go APP and provides high-level control through it. Therefore, no jailbreak or firmware manipulation is required. It works out of the box for Go2 AIR/PRO/EDU models.

	![Description of the image](./images/screenshot_1.png)

	## Supported Versions

	The currently supported firmware packages are:
	- 1.1.1 - 1.1.3 (latest available)
	- 1.0.19 - 1.0.25

	## Audio and Video Support

	There are video (recvonly) and audio (sendrecv) channels in WebRTC that you can connect to. Check out the examples in the `/example` folder.

	## Lidar support

	There is a lidar decoder built in, so you can handle decoded PoinClouds directly. Check out the examples in the `/example` folder.

	## Connection Methods

	The driver supports three types of connection methods:

	1. **AP Mode**: Go2 is in AP mode, and the WebRTC client is connected directly to it:

		```python
		Go2WebRTCConnection(WebRTCConnectionMethod.LocalAP)
		```

	2. **STA-L Mode**: Go2 and the WebRTC client are on the same local network. An IP or Serial number is required:

		```python
		Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, ip="192.168.8.181")
		```


		If the IP is unknown, you can specify only the serial number, and the driver will try to find the IP using the special Multicast discovery feature available on Go2:

		```python
		Go2WebRTCConnection(WebRTCConnectionMethod.LocalSTA, serialNumber="B42D2000XXXXXXXX")
		```

	3. **STA-T mode**: Remote connection through remote Unitrees TURN server. Could control your Go2 even being on the diffrent network. Requires username and pass from Unitree account

		```python
		Go2WebRTCConnection(WebRTCConnectionMethod.Remote, serialNumber="B42D2000XXXXXXXX", username="email@gmail.com", password="pass")
		```

	## Multicast scanner
	The driver has a built-in Multicast scanner to find the Unitree Go2 on the local network and connect using only the serial number.


	## Installation

	```sh
	cd ~
	sudo apt update
	sudo apt install python3-pip
	sudo apt install portaudio19-dev
	git clone --recurse-submodules https://github.com/legion1581/go2_webrtc_connect.git
	cd go2_webrtc_connect
	pip install -e .
	```

	## Usage 
	Example programs are located in the /example directory.

	### Thanks

	A big thank you to TheRoboVerse community! Visit us at [TheRoboVerse](https://theroboverse.com) for more information and support.

	Special thanks to the [tfoldi WebRTC project](https://github.com/tfoldi/go2-webrtc) and [abizovnuralem](https://github.com/abizovnuralem) for adding LiDAR support!

	 
	### Support

	If you like this project, please consider buying me a coffee:

	<a href="https://www.buymeacoffee.com/legion1581" target="_blank"><img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" style="height: 60px !important;width: 217px !important;" ></a>

	================
	File: setup.py
	================
	from setuptools import setup, find_packages

	setup(
		name='go2-webrtc-connect',
		version='1.0.0',
		author='legion1581',
		author_email='legion1581@gmail.com',
		packages=find_packages(),
		install_requires=[
			'aiortc==1.9.0', 
			'pycryptodome',
			'opencv-python',
			'sounddevice',
			'pyaudio',
			'requests',
			'wasmtime'
		],
	)
























